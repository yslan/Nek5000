c-----------------------------------------------------------------------
c---- MG Prec for a scalar field
c-----------------------------------------------------------------------
      subroutine scprec(z,w) ! z = M w

!     assume one scalar field, with nelt

      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL' ! TOTAL does not have HSMG

      parameter(lt=lx1*ly1*lz1*lelt)
      real     z(1), w(1)

      mxmg = 1
      isw = 0
      ifield = 2

      if(ldim.eq.3.or.param(104).gt.0.5) then ! use tensor solve
        call adfmn_mg_schwz_tens(z,w,isw,mxmg,tmult)
      else
        call adfmn_mg_schwz(z,w,isw,mxmg,tmult)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_tens_genall() ! tensor setup
      include 'SIZE'
      include 'HSMGL'
      include 'MASS'   ! bm1
      include 'TSTEP'  ! nelfld
      include 'PARALLEL' ! nid
      include 'INPUT' ! param50

      include 'SOLN' ! FIXME

      common /adfcoef/h1
      real h1(lx1,ly1,lz1,lelt)
      real tmpv(lx1,ly1,lz1,lelt)

      common /tenslog/ ifschur
      logical          ifschur

      common /tensrank/ arank
      character*3 arank(lelt,lmgn)

      common /fdmptr/ peigl,peigv
      integer peigl(lelt,lmgn), peigv(lelt,lmgn)

      common /fdm/ LL, VR, VL
      complex*16   LL(lmgn*lelt*lx1*ly1*lz1),
     $             VR(lmgn*lelt*((ldim-1)*lx1**ldim+lx1**2)),
     $             VL(lmgn*lelt*((ldim-1)*lx1**ldim+lx1**2))

      integer lwork,lsch
      parameter (lwork=2*(lzd+4)*(lxd+4)*(lyd+4))
      parameter (lsch=lmgn*lelt*(lz1**2+(2*lz1+1)*(lx1**2+ly1**2)))
      common /schur/ S, QR, QL, WK
      real S(lsch),QR(lsch),QL(lsch),WK(lwork)

      real A((lx1*ldim)**2), B((ly1*ldim)**2), C((lz1*ldim)**2)
      real h0,h2

      integer p0,p1,p2, vlen
      integer bcs(6,lelt)
      integer e

      real urank(lx1,ly1,lz1,lelt)
      integer n1,i,j,k

      h0 = 0.0E0
      h2 = 1.0E0

      ifschur = .true.
      if((param(104).gt.1.5)) ifschur = .false.

      do e=1,nelt
         two  = 2
         ierr = 0
         ifield = 2
         call adf_get_fast_bc(bcs(1,e) ,bcs(2,e)
     $                       ,bcs(3,e) ,bcs(4,e)
     $                       ,bcs(5,e) ,bcs(6,e)
     $                       ,e,two,ierr)
      enddo

      p0 = 1
      p1 = 1
      do l=mg_lmax,1,-1
         nx = mg_nh(l)
         ny = mg_nh(l)
         nz = mg_nhz(l)

         if (l.eq.mg_lmax) then ! fine grid 
           call svisc(tmpv,2)
           if (nio.eq.0) write (6,*)
     $      'adfmg_tens_genall: changing viscosity in',2,h1(1,1,1,1) 
           call adf_tens_gen(h0,h2,tmpv)
         else                   ! coarse grid
           call tens_gen_basis(nx,ny,nz)
         endif
         
         if(ldim.eq.3) then ! 3D setup
           if(ifschur) then ! Compute Schur canonical form
             if(nio.eq.0) write(6,*) 'Factoring Schur, level ',l
             do e=1,nelt
               peigl(e,l) = p0
               peigv(e,l) = p1
               call adf_als(e,arank(e,l),nx,ny,nz,A,B,C,WK)
               call schfact3d(arank(e,l),nx,ny,nz,
     $              S(p1),QR(p1),QL(p1),vlen,A,B,C,bcs(1,e),WK)
               p0 = p0 + nx*ny*nz
               p1 = p1 + vlen
             enddo ! e
           else 
             if(nio.eq.0) write(6,*) 'Factoring FDM, level ',l
             do e=1,nelt
               peigl(e,l) = p0
               peigv(e,l) = p1
               call adf_als(e,arank(e,l),nx,ny,nz,A,B,C,WK)
               call fdmfact3d(arank(e,l),nx,ny,nz,
     $              LL(p0),VR(p1),VL(p1),vlen,A,B,C,bcs(1,e) )
               p0 = p0 + nx*ny*nz
               p1 = p1 + vlen
             enddo ! e
           endif
         else ! 2D setup
           if(ifschur) then ! Compute Schur canonical form
              if(nio.eq.0) write(6,*) 'Factoring Schur, level ',l
              do e=1,nelt
                peigl(e,l) = p0
                peigv(e,l) = p1
                p2 = p1 + nx*nx
                call adf_svd(e,nx,ny,A,B,WK)
                call schfact22(nx,ny,S(p1),S(p2),QR(p1),QR(p2),
     $               QL(p1),QL(p2),A,B,bcs(1,e),WK)
                p0 = p0 + nx*ny
                p1 = p1 + nx*nx + ny*ny
              enddo ! e
           else ! Compute fast diagonalization
              if(nio.eq.0) write(6,*) 'Factoring FDM, level ',l
              do e=1,nelt
                peigl(e,l) = p0
                peigv(e,l) = p1
                p2 = p1 + nx*nx
                call adf_svd(e,nx,ny,A,B,WK)
                call fdmfact22(nx,ny,LL(p0),VR(p1),VR(p2),
     $               VL(p1),VL(p2),A,B,bcs(1,e) )
                p0 = p0 + nx*ny
                p1 = p1 + nx*nx + ny*ny
             enddo ! e
           endif
         endif
      enddo ! l

c     Debugging rank field
      n1 = lx1*ly1*lz1
      do e=1,nelt
      do k=1,lz1
      do j=1,ly1
      do i=1,lx1
         urank(i,j,k,e)= i
      enddo ! i
      enddo ! j
      enddo ! k
      enddo ! e

      ifxyo=.true.
      call outpost(vx,vy,vz,pr,urank,'ran')

      do e=1,nelt
      if(arank(e,mg_lmax).eq.'222') call cfill(urank(1,1,1,e),0.0,n1)
      if(arank(e,mg_lmax).eq.'223') call cfill(urank(1,1,1,e),1.0,n1)
      if(arank(e,mg_lmax).eq.'232') call cfill(urank(1,1,1,e),2.0,n1)
      if(arank(e,mg_lmax).eq.'322') call cfill(urank(1,1,1,e),3.0,n1)
      if(arank(e,mg_lmax).eq.'233') call cfill(urank(1,1,1,e),4.0,n1)
      if(arank(e,mg_lmax).eq.'323') call cfill(urank(1,1,1,e),5.0,n1)
      if(arank(e,mg_lmax).eq.'332') call cfill(urank(1,1,1,e),6.0,n1)
      enddo ! e

      ifxyo=.true.
      call outpost(vx,vy,vz,pr,urank,'ran')
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwzmg_tens_solve(x,r,l,nx) !
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      real    x(nx**ldim,1), r(nx**ldim,1) ! 3D declaration

      common /tenslog/ ifschur
      logical          ifschur

      common /tensrank/ arank
      character*3 arank(lelt,lmgn)

      common /fdmptr/ peigl,peigv
      integer peigl(lelt,lmgn), peigv(lelt,lmgn)

      common /fdm/ LL, VR, VL
      complex*16   LL(lmgn*lelt*lx1*ly1*lz1),
     $             VR(lmgn*lelt*((ldim-1)*lx1**ldim+lx1**2)),
     $             VL(lmgn*lelt*((ldim-1)*lx1**ldim+lx1**2))

      integer lwork,lsch
      parameter (lwork=2*(lzd+4)*(lxd+4)*(lyd+4))
      parameter (lsch=lmgn*lelt*(lz1**2+(2*lz1+1)*(lx1**2+ly1**2)))
      common /schur/ S, QR, QL, WK
      real S(lsch),QR(lsch),QL(lsch),WK(lwork)

      integer p0,p1,p2, vlen
      integer e

      ny   = mg_nh(l)
      nz   = mg_nhz(l)

      if(ldim.eq.3) then ! 3D solver
        if(ifschur) then ! Invert Schur canonical form
          do e=1,nelt
            p0 = peigl(e,l)
            p1 = peigv(e,l)
            call schsolv3d(arank(e,l),nx,ny,nz,x(1,e),
     $                     S(p1),QR(p1),QL(p1),r(1,e),WK)
          enddo ! e
        else             ! Invert Fast Diagonalization
          do e=1,nelt
            p0 = peigl(e,l)
            p1 = peigv(e,l)
            call fdmsolv3d(arank(e,l),nx,ny,nz,x(1,e),
     $                    LL(p0),VR(p1),VL(p1),r(1,e))
          enddo ! e
        endif
      else               ! 2D solver
        if(ifschur) then ! Invert Schur canonical form
          do e=1,nelt
            p0 = peigl(e,l)
            p1 = peigv(e,l)
            p2 = p1 + nx*nx
            call copy(x(1,e),r(1,e),nx*ny)
            call schsolv22(nx,ny,x(1,e),S(p1),S(p2),
     $           QR(p1),QR(p2),QL(p1),QL(p2),WK)
          enddo ! e
        else             ! Invert Fast Diagonalization
          do e=1,nelt
            p0 = peigl(e,l)
            p1 = peigv(e,l)
            p2 = p1 + nx*nx
            call fdmsolv22( nx,ny,x(1,e),LL(p0),
     $           VR(p1),VR(p2),VL(p1),VL(p2),r(1,e) )
          enddo ! e
        endif
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_mg_schwz_tens(x,res,iter,maxit,wt) !
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL' ! TOTAL does not have HSMGL

      parameter(lt=lx1*ly1*lz1*lelt)
      real     x(1), u0(1), res(1), wt(1)
      integer  iter, maxit
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      real     tol
      common /adfscr/ tmp(lt), r0(lt)
      real            tmp    , r0
      common /adfexc/ uex(lt)
      real            uex
      integer  icld
      data     icld / 0 /
      save     icld

      tol = 1.e-12
      ifield = 2 ! temp
      if(icld.eq.0) then
        lv = max(nint(param(81)),2)
c       lv = 4
c       lv = 3
c       lv = 2
        if(nio.eq.0)
     $    write(6,*) 'adfmn_mg_schwz_tens: into setup_tens, levels=',lv
        call adfmn_schwzmg_setup_tens(lv)
        icld = icld + 1
      endif

      n = nx1*ny1*nz1*nelt
      resn = sqrt(glsc2(res,res,n))
      if (nio.eq.0) write(6,*) 'adf schwz ml: initial residual', resn
      call copy (r0, res, n)
      call rzero(x,n)

c     maxit = 10
      iter = 0
      do it=1,maxit
        call adfmn_schwzmg_solve_v_tens(tmp,r0,icrs) ! v-cycle
        iter = iter + icrs
        call add2(x,tmp,n)
        call adfax (r0,x,h1)   !
c         call outpost(vx,vy,vz,pr,r0,'   ')
        call sub2  (r0,res,n)
        call chsign(r0,n)      ! r0 = res - A x
        rn0 = sqrt(glsc2(r0,r0,n))

c       if(mod(it,10).eq.0) then
c         call sub3(tmp,x,uex,n)
c         call outpost(vx,vy,vz,pr,tmp,'   ')
c         call outpost(vx,vy,vz,pr,x,'   ')
c       endif

        if(rn0.le.tol) then
          if(nio.eq.0) write(6,10) it, maxit, rn0, resn, tol
          goto 88
        endif
        if(nio.eq.0)   write(6, 9) it, maxit, rn0, resn, tol
      enddo
   9  format(2i5,1p3e12.4, ' mgshwz')
   10 format(2i5,1p3e12.4, ' mgshwzb')
   88 continue
c     call outpost(vx,vy,vz,pr,r0,'   ')
c     call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_schwzmg_setup_tens(lv)
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'
      include 'SEMHAT'

      parameter (lxyz = lx1*ly1*lz1, 
     $           lxxe = lx1*lx1*lelt, lyye  = ly1*ly1*lelt,
     $           lzze = lz1*lz1*lelt, lxyze = lxyz*lelt    )

      common /fastmd/ ifdfrm(lelt), iffast(lelt), ifh2, ifsolv
      logical         ifdfrm, iffast, ifh2, ifsolv
      common /scrhi/ h2inv (lx1,ly1,lz1,lelt)
      common /scrvh/ h2    (lx1,ly1,lz1,lelt)
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /adfco/  co
      real            co(lmg_g*(ldim)*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?
      common /logmn/ ifrstr
      logical        ifrstr

      integer p_h1,p_h2,p_g,p_b,p_msk,e,p_c,p_el,p_ev
      integer icall
      save    icall
      data    icall /0/

      if (nio.eq.0) write(6,*) 'adf: famg_setup',icall,ifield
      icall = icall+1
      if (icall.gt.10) stop

      ifrstr = .true.  ! RAS
      ifrstr = .false. ! WAS
      if(ifrstr) then
        if(nio.eq.0) write(6,*) 'adfmn_schwzmg: Restricted AS'
      else
        if(nio.eq.0) write(6,*) 'adfmn_schwzmg: Weighted   AS'
      endif

      param(59) = 1
      do e=1,nelt
         ifdfrm(e)=.true.
      enddo
      call geom_reset(1)  ! Recompute g1m1 etc. with deformed only

      n = lx1*ly1*lz1*nelt
      call rzero(h2   ,n)
      call rzero(h2inv,n)

      mg_fld = ifield
      call adfmg_index_0 ! initialize index sets
      call adfamg_setup_nx(lv)! Sets the level schedules
      call adfmg_setup_semhat ! SEM hat matrices for each level
      call adfmg_setup_intp   ! Interpolation operators
      call adfmg_setup_dssum  ! set direct stiffness summation handles
      call adfmg_setup_wtmask ! set restriction weight matrices and bc masks
      call adf_swap_lengths   ! need to have lengths before build
      call adf_swap_lengths_fix  ! hack so that no lengths are 0
      call adfmn_setup_schwzmn_wt(.false.)
      call adfmg_setup_solve  ! set up the solver

      l=mg_h1_lmax ! == mg_lmax
      call adfmg_set_h1  (p_h1 ,l)
      call adfmg_set_h2  (p_h2 ,l)
      call adfmg_set_gb  (p_g  ,p_b,l)
      call adfmg_set_msk (p_msk,l) ! pointers to imask
      call adfmg_set_co  (p_c,l)   ! c coefficients

c     call outpost(vx,vy,vz,pr,bm1,'   ')
c     call outpost(vx,vy,vz,pr,mg_b(p_b),'   ')
c     call adfmg_dssum(mg_b(p_b),l)
c     call outpost(vx,vy,vz,pr,mg_b(p_b),'   ')
c     call exitt

c     write(6,*) 'adfmg schwz setup tens:: into tens genall'
      call adfmg_tens_genall()

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_schwzmg_solve_v_tens(z,rhs,icrs) ! V-cycle

      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'
      include 'HSMGL'

      parameter(lt=lx1*ly1*lz1*lelt)

      real z(lt),rhs(lt)                        ! z = M \ rhs
      common /zcrhi/ h2inv(lt)                  ! Work arrays
      common /zcrvh/ h2(lt)
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /zcrcq/ e(4*lt), r(4*lt),w(lt)

      common /adfexc/ uex
      real            uex(lt)
      real            err(lt)

      integer p_msk,p_b,icrs
      integer icall
      save    icall
      data    icall /0/

      ifield=2
      nel = nelfld(ifield)
      nel = nelt
      ntot=lx1*ly1*lz1*nel !

      if (icall.eq.0) then
         icall=1
         call rzero (h2   , ntot)
         call rzero (h2inv, ntot)
      endif

      sigma =  0.5
      sigma =  0.25
      op    =  1.0                           ! Coefficients for residual
      om    = -1.0                           !    evaluation
      o0    =  0.0                           !    evaluation

      nsmth = 5 !

      do iv=1,1

       l  = mg_h1_lmax
       n  = mg_h1_n(l, mg_fld)
       is = 1                                   ! Solve index

       if (iv.eq.1) then
        call rzero        (z,n) ! make zero
        call copy         (r,rhs,n)             ! r := rhs
        do ism=1,nsmth
        rmx = glmax(r,n)
        rmn = glmin(r,n)
c       if(nio.eq.0) write(6,*) ism,rmx,rmn,n,'r mx in smth a'
        call adfmn_schwz_l_tens(e,r,sigma,l)         ! z := S r
c         call exitt

        call add2          (z,e,n)
        call adfmn_axmg    (r,e,op,om,l,w)       ! r := r - Ae

c       call exitt
        rmx = glmax(r,n)
        rmn = glmin(r,n)
c       if(nio.eq.0) write(6,*) ism,rmx,rmn,'r mx in smth b'
        emx = glmax(e,n)
        emn = glmin(e,n)
        zmx = glmax(z,n)
        zmn = glmin(z,n)
c       if(nio.eq.0) write(6,*) ism,n,emx,emn,zmx,zmn,'e,z mx in smth'
c       call outpost(e,z,vz,pr,r,'   ')
c       call exitt
        enddo
       else
        call copy         (r,rhs,n)             ! r := rhs
        call adfmg_axm     (r,z,op,om,l,w)       ! r := r - Az
        do ism=1,nsmth
        call adfmn_schwz_l_tens(e,r,sigma,l)         ! e := S r
        call add2         (z,e,n)               ! z := z+e
        call adfmn_axmg    (r,e,op,om,l,w)       ! r := r - Ae
        enddo
       endif

       do l = mg_h1_lmax - 1, 2, -1             ! Restrict down to
         is = is + n                            ! coarse level
         n  = mg_h1_n(l, mg_fld)                !       T
         call adfmg_rstr(r, l, .true.)           ! r := J  r
         call adfmn_schwz_l_tens(e(is),r,sigma,l)     ! e := sigma W S r
         call adfmn_axmg(r,e(is),op,om,l,w)       ! r := r - A e
c        if (nio.eq.0) write(6,*) 'multi level restr ',l
       enddo

       ! previous lowest level
       is = is + n
       l  = 1                                   !        T
       ! this is incorrect for my use?
c      call adfmg_rstr(r, l, .false.)            ! r  := J  r
       ! this is correct?
       call adfmg_rstr(r, l, .true.)            ! r  := J  r
       p_msk=p_mg_msk(l, mg_fld)

         nlow = mg_h1_n(l, mg_fld)
         rmn = glmin(r,nlow)
         rmx = glmax(r,nlow)
c      if (nio.eq.0)  
c    $  write(6,*) rmn,rmx,'r max values before coarse solve'
c       call exitt

       call adfmg_mask(r, mg_imask(p_msk), nel)  !       -1    Mask and
       call adfmn_coarse_solve(e(is), r,icrs)         ! e := A  r   solve at 
       call adfmg_mask(e(is),mg_imask(p_msk),nel)!  1    1  1  coarse level

c      call adfmg_outpost(e(is),l)
c      call adfmg_debug_coarse(e(is),mg_nh(l))
c        call exitt

       do l = 2, mg_h1_lmax-1                   ! Prolongate to finest level
         n  = mg_h1_n(l,mg_fld)
         im = is
         is = is - n
         call adfmg_intp (w,e(im),l-1)           ! w  :=  J e
         call add2      (e(is),w,n)             ! e  := e  + w
c        if(nio.eq.0) write(6,*) 'multi level prolong',l
c        call adfmg_outpost(e(is),l)
       enddo

       l = mg_h1_lmax
       n = mg_h1_n(l,mg_fld)
       im = is
       call adfmg_intp(w,e(im),l-1)              ! w :=  J e
       call add2     (z,w,n)                    ! e  := e  + w
       call col2     (z,tmask,n)                ! mask z
       call dsavg    (z)                        ! ensure continuous z
      enddo
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_l_tens(e,r,sigma,l) !h1mg_schwarz
      include 'SIZE'
      include 'HSMGL'
      include 'SOLN'

      real    e(1),r(1)
      real    sigma
      integer l
      common /logmn/ ifrstr
      logical        ifrstr

      n  = mg_h1_n(l,mg_fld)
      nh = mg_nh(l)

      call adfmn_schwz_l_tens_part1 (e,r,l) ! !
      if(ifrstr) then
        ! do nothing
        ! write(6,*) 'doing nothing in schwz l RAS path'
      else
        call adfmg_schwarz_wt  (e,l)          ! e  := W e
      endif
      call cmult               (e,sigma,n)    !  l       l
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_l_tens_part1(e,r,l)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'TSTEP'  ! ifield
      include 'HSMGL'
      include 'SOLN'

      real    e(1),r(1)

      integer enx,eny,enz,pmsk
      real    tmp(lx1,ly1,lz1,lelt)
      common /logmn/ ifrstr
      logical        ifrstr

      zero =  0
      one  =  1
      onem = -1

      n  = mg_h1_n (l,mg_fld)
      pmsk = p_mg_msk(l,mg_fld)
      nx = mg_nh(l)

      ifield = 2
      call adfmg_mask (r,mg_imask(pmsk),nelfld(ifield))
      call adfmn_schwzmg_tens_solve(e,r,l,nx) !

      if(ifrstr) then
        ! write(6,*) 'doing masking in schwz l part 1 RAS path'
        call adfmn_schwz_rs(e,l) !
      endif

      call adfmg_dssum(e,l)                           ! sum border nodes
      call adfmg_mask (e,mg_imask(pmsk),nelfld(ifield)) ! apply mask 

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_mg_schwz(x,res,iter,maxit,wt) ! multi level
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL' ! TOTAL does not have HSMGL

      parameter(lt=lx1*ly1*lz1*lelt)
      real     x(1), u0(1), res(1), wt(1)
      integer  iter, maxit
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /adfscr/ tmp(lt), r0(lt)
      real            tmp    , r0
      common /adfexc/ uex
      real            uex(lt)
      real     tol
      integer  icld
      data     icld / 0 /
      save     icld

      tol = 1.e-12
      ifield = 2 ! temp
      if(icld.eq.0) then
        if (nio.eq.0) 
     $  write(6,*) 'adf_mg_schwz: into adf schwzmg setup'
        lv = 2
        lv = max(nint(param(81)),2)
        call adfmn_schwzmg_setup(lv)
        icld = icld + 1
      endif

      n = nx1*ny1*nz1*nelt
      resn = sqrt(glsc2(res,res,n))
      if (nio.eq.0) write(6,*) 'adf schwz ml: initial residual', resn
      call copy (r0, res, n)
      call rzero(x,n)

c     maxit = 10
      iter = 0
      do it=1,maxit
        call adfmn_schwzmg_solve_v(tmp,r0,icrs) ! v-cycle
        iter = iter + icrs
        call add2(x,tmp,n)
        call adfax (r0,x,h1)   !
c         call outpost(vx,vy,vz,pr,r0,'   ')
        call sub2  (r0,res,n)
        call chsign(r0,n)      ! r0 = res - A x
        rn0 = sqrt(glsc2(r0,r0,n))

c       if(mod(it,1 ).eq.0) then
c         call sub3(tmp,x,uex,n)
c         call outpost(vx,vy,vz,pr,tmp,'   ')
c         call outpost(vx,vy,vz,pr,x,'   ')
c       endif

        if(rn0.le.tol) then
          if(nio.eq.0) write(6,10) it, maxit, rn0, resn, tol
          goto 88
        endif
        if(nio.eq.0)   write(6, 9) it, maxit, rn0, resn, tol
      enddo
   9  format(2i5,1p3e12.4, ' mgshwz')
   10 format(2i5,1p3e12.4, ' mgshwzb')
   88 continue
c     call outpost(vx,vy,vz,pr,r0,'   ')

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_schwzmg_solve_v(z,rhs,icrs) ! V-cycle

      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'
      include 'HSMGL'

      parameter(lt=lx1*ly1*lz1*lelt)

      real z(lt),rhs(lt)                        ! z = M \ rhs
      common /zcrhi/ h2inv(lt)                  ! Work arrays
      common /zcrvh/ h2(lt)
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /zcrcq/ e(4*lt), r(4*lt),w(lt)

      common /adfexc/ uex
      real            uex(lt)
      real            err(lt)

      integer p_msk,p_b
      integer icall
      save    icall
      data    icall /0/

      ifield=1
      nel = nelfld(ifield)
      nel = nelt
      ntot=lx1*ly1*lz1*nel !

      if (icall.eq.0) then
         icall=1
         call rzero (h2   , ntot)
         call rzero (h2inv, ntot)
      endif

      sigma =  0.5
      op    =  1.0                           ! Coefficients for residual
      om    = -1.0                           !    evaluation
      o0    =  0.0                           !    evaluation

      nsmth = 5 !

      do iv=1,1

       l  = mg_h1_lmax
       n  = mg_h1_n(l, mg_fld)
       is = 1                                   ! Solve index

       if (iv.eq.1) then
        call rzero        (z,n) ! make zero
        call copy         (r,rhs,n)             ! r := rhs
c       call outpost(vx,vy,vz,pr,r,'   ')
        do ism=1,nsmth
        call adfmn_schwz_l (e,r,sigma,l)         ! z := S r
        call add2          (z,e,n)
        call adfmn_axmg    (r,e,op,om,l,w)       ! r := r - Ae
        enddo
c       call outpost(vx,vy,vz,pr,r,'   ')
       else
        call copy         (r,rhs,n)             ! r := rhs
        call adfmg_axm     (r,z,op,om,l,w)       ! r := r - Az
        do ism=1,nsmth
        call adfmn_schwz_l (e,r,sigma,l)         ! e := S r
        call add2         (z,e,n)               ! z := z+e
        call adfmn_axmg    (r,e,op,om,l,w)       ! r := r - Ae
        enddo
       endif

c      call outpost(vx,vy,vz,pr,r,'   ') ! by here is NaN!

       do l = mg_h1_lmax - 1, 2, -1             ! Restrict down to
         is = is + n                            ! coarse level
         n  = mg_h1_n(l, mg_fld)                !       T
         call adfmg_rstr(r, l, .true.)           ! r := J  r
         call adfmn_schwz_l(e(is),r,sigma,l)     ! e := sigma W S r
         call adfmn_axmg(r,e(is),op,om,l,w)       ! r := r - A e
        write(6,*) 'should not be in here for two level'
       enddo

       ! previous lowest level
       is = is + n
       l  = 1                                   !        T
       ! this is incorrect for my use?
c      call adfmg_rstr(r, l, .false.)            ! r  := J  r
       ! this is correct?
       call adfmg_rstr(r, l, .true.)            ! r  := J  r
       p_msk=p_mg_msk(l, mg_fld)

c        nlow = mg_h1_n(l, mg_fld)
c        rmn = glmin(r,nlow)
c        rmx = glmax(r,nlow)
c        write(6,*) rmn,rmx,'r max values before coarse solve'

       call adfmg_mask(r, mg_imask(p_msk), nel)  !       -1    Mask and
       call adfmn_coarse_solve(e(is), r,icrs)         ! e := A  r   solve at 
       call adfmg_mask(e(is),mg_imask(p_msk),nel)!  1    1  1  coarse level

c      call adfmg_debug_coarse(e(is),mg_nh(l))
c        rmn = vlmin(e(is),nlow)
c        rmx = vlmax(e(is),nlow)
c        write(6,*) rmn,rmx,'e max values after coarse solve'
c        call exitt

       do l = 2, mg_h1_lmax-1                   ! Prolongate to finest level
         n  = mg_h1_n(l,mg_fld)
         im = is
         is = is - n
         call adfmg_intp (w,e(im),l-1)           ! w  :=  J e
         call add2      (e(is),w,n)             ! e  := e  + w

         write(6,*) 'should not be in here for two level: loc b'
       enddo

       l = mg_h1_lmax
       n = mg_h1_n(l,mg_fld)
       im = is
       call adfmg_intp(w,e(im),l-1)              ! w :=  J e
       call add2     (z,w,n)                    ! e  := e  + w
       call col2     (z,tmask,n)                ! mask z
       call dsavg    (z)                        ! ensure continuous z
      enddo
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_coarse_solve(e,r,icrs)
      include 'SIZE'
      include 'DOMAIN'
      include 'ESOLV'
      include 'GEOM'
      include 'SOLN'
      include 'PARALLEL'
      include 'HSMGL'
      include 'CTIMER'
      include 'INPUT'
      include 'TSTEP'
      real    e(1),r(1)
      real    w(lx1*ly1*lz1*lelt), tmp(lx1*ly1*lz1*lelt)
      integer l
      real    eu(lx1*ly1*lz1*lelt)
c
      integer n_crs_tot
      save    n_crs_tot
      data    n_crs_tot /0/
      real    r0(lx1*ly1*lz1*lelt)
      integer p_msk

      real  is
c
      if (icalld.eq.0) then ! timer info
         ncrsl=0
         tcrsl=0.0
      endif
      icalld = 1

      if (ifsync) call nekgsync()

      ncrsl  = ncrsl  + 1
      etime1=dnekclock()

      ! repeated Schwarz until converges
      l  = 1 ! lowest level
      nh = mg_nh  (l)
      nr = mg_h1_n(l,mg_fld)
      mxc = 20
      mxc = 100
      mxc = 200
      mxc = min(lgmres,mxc)
      nel = nelfld(mg_fld)
      rn0 = sqrt(glsc2(r,r,nr))
      if(nio.eq.0) write(6,*) 'coarse: initial norm of r',rn0
      rnt = rn0*tol ! relative tolerance?
      call copy (r0,r,nr)
      call rzero(e,nr)
      p_msk=p_mg_msk(l, mg_fld)

      call adfmn_proj(e,r,icrs,mxc,l)

      tcrsl=tcrsl+dnekclock()-etime1

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_proj_test
      include 'SIZE'
      include 'HSMGL'
      include 'TOTAL'
      parameter(lt=lx1*ly1*lz1*lelt)

      real    x(lt),res(lt)
      real    sigma
      real    r(lt), w(lt)
      integer maxit,l

      common /adfexc/ uex
      real            uex(lt)
      integer pmsk

      op = 1.
      om = -1.
      zr = 0.

      ifield = 2 ! needed
      lv = 2
      lv = max(nint(param(81)),2)
      call adfmn_schwzmg_setup(lv) ! setup is required ofr adf_mg_schwz

      l = 1
      n = mg_h1_n(l,mg_fld) ! (4x4) x nel
      nh = mg_nh(l)
      pmsk=p_mg_msk(l, mg_fld)

      call rone(r,n)
      call copy(w,r,n)

c     write(6,*) 'all ones',pmsk,nid
c     call adfmg_debug_coarse(w,nh)

      call adfmg_mask(w,mg_imask(pmsk),nelt)

c     write(6,*) 'correct mask?'
c     call adfmg_debug_coarse(w,nh)

      call sub2(r,w,n) ! keep boundary points

      if (nio.eq.0) write(6,*) 'setup boundary valuesa',nid
      call adfmg_debug_coarse(r,nh)

      call adfmn_axmg(res,r,zr,om,l,w)

      call copy(uex,r,n) ! save boundary

      if (nio.eq.0) write(6,*) 'setup residual',nid
      call adfmg_debug_coarse(res,nh)

      call copy(r,res,n)
      call rzero(x,n)

      if (nio.eq.0)write(6,*) nid,l,nh,n,nelt,'adfmn_proj_test: l,n'
      tol = 1.e-12
      call rzero(x,n)
      mxmg = 300 ! converges in ~310, w/ coarse schwarz prec
      mxmg = 600 ! not converged in 500, w/ no prec
                 ! so the schwarz prec breaks symmetry, but
                 !  is still faster than no prec.
      mxmg = 50
c     do i=1,mxs
        call adfmn_proj   (w,r,icrs,mxmg,l) !
        call add2         (x,w,n)

c       call adfmg_debug_coarse(x,nh)

        call copy         (r,res,n)
        call adfmn_axmg   (r,x,op,om,l,w)       ! r := r - Az

c       call adfmg_debug_coarse(r,nh)

        rn = sqrt(glsc2(r,r,n))
        if(rn.le.tol) goto 88
        if (nio.eq.0) write(6,*) i,rn,tol,' adfmn proj test',nid
c     enddo

      call add2(x,uex,n)
c     call adfmg_debug_coarse(x,nh)

   88 continue

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_proj(x,res,iter,maxit,l)

c     Solve A t = r, via custome projection scheme

      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'

      parameter(lt=lx1*ly1*lz1*lelt)
      real    res(1), x(1)
      integer iter, maxit, l

      real r(lt),w(lt),d(lt),v(lt),z(lt), wt(lt) ! multiplicity
      common /dcrspj/ d       ! scratch
      common /ccrspj/ r,w     ! WORK ARRAYS
      common /zcrsp1/ v
      common /zcrsp2/ z
      common /zcrsps/ p,q
      real            p(lt,lgmres), q(lt,lgmres)
      real    x0(lt)
      real    proj_tol
      real    alpha, beta

      common /adfexc/ uex
      real            uex(lt)
      logical         iflu

      ngo = -99        ! TURN OFF VERBOSE OUTPUT
      n = mg_h1_n(l,mg_fld) ! length for multigrid(< ntot)
      nh = mg_nh  (l)
      proj_tol = 1.e-10
      if (istep.le.20.or.mod(istep,10).eq.0) ngo = nio

      iflu = .true.
      if(param(104) .gt. 0.5) iflu = .false.
      if(ldim.eq.3) iflu = .false.
      if(nio.eq.0) write(6,*) 'adfpj crs: if using LU:',iflu

      m   = lgmres
      mxs = 1 ! maximum schwarz iter - once?
      iconv = 0 ! if converged
      sigma = 0.5
      zr = 0.
      op = 1.

      ! initial guess
      call rzero(x,n)                     ! Solution

c     write(6,*) 'res ',(res(i),i=1,n)
      rn0 = sqrt(glsc2(res,res,n))
      rn = rn0*1.e-2
      rn = rn0*1.e-5
      proj_tol = max(rn,proj_tol)

      iter = 1
      do while (iter.lt.maxit)    ! Main proj loop
         if(iter.eq.1) then                      ! first step :: r = res - A 0
            call copy   (r,res,n)
         else                                     ! second up  :: r = res - A x
            call adfmn_axmg(w,x,zr,op,l,d)        ! w = A x
            call sub3   (r,res,w,n)               ! r = r - w
         endif

         ! precoditioner solve
                                                  !       -1
c        call copy  (z,r,n)                       ! z  = M  v
                                                  !  j       j
         if(iflu) then
           call adfmn_schwz_l     (z,r,sigma,l)   ! z  = M  v
         else                                     !  j       j
           call adfmn_schwz_l_tens(z,r,sigma,l)
         endif

         call adfmn_axmg(w,z,zr,op,l,d)           ! w = A z
                                                  !       j
c        write(6,*) ' w   ',(w(i),i=1,n)
c        call exitt
c        call adfmg_debug_coarse(r,nh)
c        call adfmg_debug_coarse(z,nh)
c        call adfmg_debug_coarse(w,nh)
         do j=1,(iter-1)
           beta = glsc2(q(1,j),w,n)
           call add2s2(z,p(1,j),-beta,n)
           call add2s2(w,q(1,j),-beta,n)
         enddo
         beta = sqrt(glsc2(w,w,n))
         if(beta.lt.proj_tol) goto 900

         betai = 1./beta
         call copy (p(1,iter),z,n)
         call cmult(p(1,iter),betai,n)
         call copy (q(1,iter),w,n)
         call cmult(q(1,iter),betai,n)

         alpha = glsc2(q(1,iter),r,n)
         call add2s2(x,p(1,iter),alpha,n)

         if (ngo.eq.0) write(6,9)
     $         n,iter,beta,alpha,proj_tol,dt
    9    format(i9,i5,1p4e12.4,' mgprj')
         iter = iter + 1

c        if(mod(iter,5).eq.0)
c    $     call adfmg_debug_coarse(x,nh)
c          call adfmg_debug_coarse(z,nh)
c          call adfmg_debug_coarse(x,nh)
c          call adfmg_debug_coarse(x,nh)
      enddo
  900 continue
      maxit = iter
      if (nio.eq.0) write(6,8)
     $   n,maxit,beta,proj_tol,dt
    8    format(i9,i5,1p3e12.4,' mgprjb')

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwzmg_test(e,res,sigma,maxit) !h1mg_schwarz
      include 'SIZE'
      include 'HSMGL'
      include 'SOLN'
      include 'INPUT'

      parameter(lt=lx1*ly1*lz1*lelt)
      integer l, maxit

      real e(1),res(1)
      real sigma
      real r(lt), w(lt)

      common /adfexc/ uex
      real            uex(lt)

      op = 1.
      om = -1.

      ifield = 2 ! needed
      lv = 2
      lv = max(nint(param(81)),2)
      call adfmn_schwzmg_setup(lv) !

      l = mg_h1_lmax
      n = mg_h1_n(l,mg_fld)
      call copy(r,res,n)

      write(6,*) l,n,'adfmn_schwzmg_test: l,n'
      tol = 1.e-10
      call rzero(e,n)
      do i=1,maxit
        call adfmn_schwz_l(w,r,sigma,l)  ! !
        call add2         (e,w,n)
        call copy         (r,res,n)
        call adfmn_axmg   (r,e,op,om,l,w) ! ! r := r - Az

        rn = sqrt(glsc2(r,r,n))
        if(rn.le.tol) goto 88
        write(6,*) i,rn,tol,'adfmn schwzmg test'
        if(mod(i,10).eq.0)
     $    call outpost(vx,vy,vz,pr,e,'   ')
      enddo
   88 continue

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_axmg(w,p,aw,ap,l,wk)
c
c     w  := aw*w + ap*H*p, level l, with mask and dssum
c
c     Hu := div. h1 grad u + h2 u
c
c        ~= h1 A u + h2 B u
c
c     Here, we assume that pointers into g() and h1() and h2() have
c     been established
c
      include 'SIZE'
      include 'HSMGL'
      include 'TSTEP'  ! nelfld

      real w(1),p(1),wk(1)

      integer p_h1,p_h2,p_g,p_b,p_msk, p_c
      logical ifh2
      common /adfco/  co
      real            co(lmg_g*(ldim)*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?

      real aw, ap

      p_h1  = p_mg_h1  (l,mg_fld)
      p_h2  = p_mg_h2  (l,mg_fld)
      p_g   = p_mg_g   (l,mg_fld)
      p_b   = p_mg_b   (l,mg_fld)
      p_msk = p_mg_msk (l,mg_fld)
c     write(6,*) 'inside adfmg axm:: p_msk',p_msk,l
      p_c   = pco      (l,mg_fld) ! right

      if (p_h1 .eq.0) call adfmg_set_h1  (p_h1 ,l)
      if (p_h2 .eq.0) call adfmg_set_h2  (p_h2 ,l)
      if (p_g  .eq.0) call adfmg_set_gb  (p_g,p_b,l)
      if (p_msk.eq.0) call adfmg_set_msk (p_msk,l)
      if (p_c  .eq.0) call adfmg_set_co  (p_c,l)

      ifh2 = .false.

      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)
      ng = 3*ldim-3
      nc = ldim

      ! update to have c !
      call adfmg_axml (wk,p
     $               ,mg_h1(p_h1),mg_h2(p_h2),nx,ny,nz,nelfld(ifield)
     $               ,mg_g (p_g) , ng ,mg_b(p_b), mg_imask(p_msk),ifh2
     $               , co(p_c), nc)

      ! wk = C p + A p

c     n = nx*ny*nz*nelfld(ifield)
      n = nx*ny*nz*nelfld(mg_fld)
      call adfmg_dssum  (wk,l) ! hsmg_dssum

      ! w = aw * w + ap * wk = 1 * w - 1 * wk = w - ( C p + A p)
      call add2sxy    (w,aw,wk,ap,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_schwzmg_setup(lv)
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'
      include 'SEMHAT'

      parameter (lxyz = lx1*ly1*lz1, 
     $           lxxe = lx1*lx1*lelt,
     $           lyye = ly1*ly1*lelt,
     $           lzze = lz1*lz1*lelt,
     $           lxyze = lxyz*lelt    )

      common /fastmd/ ifdfrm(lelt), iffast(lelt), ifh2, ifsolv
      logical  ifdfrm, iffast, ifh2, ifsolv

      common /scrhi/ h2inv (lx1,ly1,lz1,lelt)
      common /scrvh/ h2    (lx1,ly1,lz1,lelt)
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /adfco/  co
      real            co(lmg_g*(ldim)*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?

      common /logmn/ ifrstr
      logical        ifrstr

      integer p_h1,p_h2,p_g,p_b,p_msk,e, p_c, p_e

      integer icall
      save    icall
      data    icall /0/

      write(6,*) 'adf: famg_setup',icall,ifield
      icall = icall+1
      if (icall.gt.10) stop

      ifrstr = .true.  ! RAS
      ifrstr = .false. ! WAS

      if(ifrstr) then
        if(nio.eq.0) write(6,*) 'adfmn_schwzmg: Restricted AS'
      else
        if(nio.eq.0) write(6,*) 'adfmn_schwzmg: Weighted   AS'
      endif

      param(59) = 1
      do e=1,nelt
         ifdfrm(e)=.true.
      enddo
      call geom_reset(1)  ! Recompute g1m1 etc. with deformed only

      n = lx1*ly1*lz1*nelt

      call rzero(h2   ,n)
      call rzero(h2inv,n)

      mg_fld = ifield
      call adfmg_index_0 ! initialize index sets
      call adfamg_setup_nx(lv)! Sets the level schedules
      call adfmg_setup_semhat ! SEM hat matrices for each level
      call adfmg_setup_intp   ! Interpolation operators
      call adfmg_setup_dssum  ! set direct stiffness summation handles
      call adfmg_setup_wtmask ! set restriction weight matrices and bc masks
      call adf_swap_lengths   ! need to have lengths before build
      call adf_swap_lengths_fix  ! hack so that no lengths are 0
      call adfmn_setup_schwzmn_wt(.false.)
      call adfmg_setup_solve  ! set up the solver

      l=mg_h1_lmax ! == mg_lmax
      call adfmg_set_h1  (p_h1 ,l)
      call adfmg_set_h2  (p_h2 ,l)
      call adfmg_set_gb  (p_g  ,p_b,l)
      call adfmg_set_msk (p_msk,l) ! pointers to imask
      call adfmg_set_co  (p_c,l)   ! c coefficients

c     write(6,*) 'adfmg schwz setup:: into build lb'
      call adfmg_schwzmn_buildlb() ! ! build element local matrices

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwzmn_buildlb() ! h1mg_setup_fdm
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      
      integer l,i,j,nl

      common /adflng/ lb ! system to solve
      real            lb(lx1**2,lx1**2,lelt,lmgn) ! so large
      integer lbr,rbr,lbs,rbs,lbt,rbt,two,ierr

      ifield=2
      two = 2
      ierr = 0
      do l=1,mg_lmax ! does not start from lowest one??
         nl = mg_nh(l)
         write(6,*) l,nl,mg_nh(l),'levels'
         call adfmg_schwzmn_build_l(lb(1,1,1,l),nl,l) ! level l
      enddo
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwzmn_build_l(lb,nl,l) ! minimal overlap
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      include 'SOLN' ! to vx, vy, vz
      include 'GEOM'
      integer l,i,j,nl
      real    lb(nl**ldim,nl**ldim,1)
      integer lbr,rbr,lbs,rbs,lbt,rbt,two
      integer ierr
      integer ph1, pg, pb, pc
      common /adfco/  co
      real            co(lmg_g*(ldim)*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?
      common /logmn/ ifrstr
      logical        ifrstr

c     write(6,*) 'build lb: before printing l'
c     do ie=1,nelt
c     write(6,*) ie,llr(ie),lmr(ie),lrr(ie),lls(ie),lms(ie),lrs(ie),'l'
c     enddo

      nx   = mg_nh(l)
      ny   = mg_nh(l)
      nz   = 1          ! 2D
      if(ldim.eq.3) nz = nx
      nxyz = nx*ny*nz

      ph1  = p_mg_h1(l,mg_fld)
      pb   = p_mg_b (l,mg_fld)
      pg   = p_mg_g (l,mg_fld)
      pc   = pco    (l,mg_fld)

      nc = ldim
      ng = 3*(ldim-1)

      two  = 2
      ierr = 0
      i = 1
      do ie=1,nelt
         ifield = 2
         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
         call adfmn_build_lbe_l(lb(1,1,ie),lbr,rbr,lbs,rbs,lbt,rbt
     $        ,mg_h1(ph1),mg_g(pg),mg_b(pb),co(pc),ng,nc,l,nl,ie)
         ph1  = ph1 + nxyz    ! element count
         pb   = pb  + nxyz    ! element count
         pc   = pc  + nc*nxyz
         pg   = pg  + ng*nxyz ! element count
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe_l(lbe,lbx,rbx,lby,rby,lbz,rbz
     $                            ,h1,gf,bm,co,ng,nc,l,nl,ie)
      include 'SIZE'

      integer lbx,rbx,lby,rby,lbz,rbz
      real    lbe(1) ! build array
      real    h1(1), gf(1), bm(1), co(1)
      real    llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz

      if(ldim.eq.3) then
        call adfmn_build_lbe_3d_l(lbe,lbx,rbx,lby,rby,lbz,rbz
     $                            ,h1,gf,bm,co,ng,nc,l,nl,ie)
      else
        call adfmn_build_lbe_2d_l(lbe,lbx,rbx,lby,rby
     $                            ,h1,gf,bm,co,ng,nc,l,nl,ie)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe_3d_l(Lbe,lbx,rbx,lby,rby,lbz,rbz
     $                               ,h1,gf,bm,co,ng,nc,l,nl,ie)
      include 'SIZE'
      include 'HSMGL' ! mg_dh

      parameter(le=lx1*ly1*lz1)

      integer lbx,rbx,lby,rby,lbz,rbz
      real    Lbe(nl,nl,nl,nl,nl,nl) ! build array, 3D
      real    h1(   nl,nl,nl), bm(   nl,nl,nl)
     $      , gf(ng,nl,nl,nl), co(nc,nl,nl,nl)
      integer l,nl,ie, i, j, k, o, p, q

      common /adfscr/ dr, drt, ds, dst, tmpr, tmps, wrk
      real    dr  (le*le) , drt (le*le)
     $      , ds  (le*le) , dst (le*le)
     $      , dt  (le*le) , dtt (le*le)
     $      , tmpr(le*le) , tmps(le*le)    , tmpt(le*le)    
     $      , wrk (le*le) , wrk2(le*le)

      n    = nl    ! 1D points
      n2   = n*n
      np   = n*n*n ! number of points

      call gen_iden(wrk,n)
      call kron2(wrk2,wrk,n,n,mg_dh(1,l),n,n) !  I x D
      call kron2(dr  ,wrk,n,n,wrk2,n2,n2)     !  I x (I x D)
      call kron2(ds  ,wrk2,n2,n2,wrk,n,n)     ! (I x D) x I
      call kron2(wrk2,mg_dh(1,l),n,n,wrk,n,n) !  D x I
      call kron2(dt  ,wrk2,n2,n2,wrk,n,n)     ! (D x I) x I

      call transpose(drt,np,dr,np)
      call transpose(dst,np,ds,np)
      call transpose(dtt,np,dt,np)

      call rzero(lbe,np*np)
      do q=1,n
      do p=1,n
      do o=1,n
      do k=1,n
      do j=1,n
      do i=1,n
        hv = h1(i,j,k)
        ij = i + (j-1)*n + (k-1)*n2
        iv = i + (j-1)*n + (k-1)*n2 + (o-1)*np + (p-1)*np*n
     $                                         + (q-1)*np*n2
        g1 = gf(1,i,j,k) ! rr
        g2 = gf(2,i,j,k) ! ss
        g3 = gf(3,i,j,k) ! tt
        g4 = gf(4,i,j,k) ! rs
        g5 = gf(5,i,j,k) ! rt
        g6 = gf(6,i,j,k) ! st
c       write(6,*) i,j,k,n,g1,g2,g3,g4,g5,g6,hv,'coef'
        tmpr(iv) = hv * (g1*dr(iv) + g4*ds(iv) + g5*dt(iv))
        tmps(iv) = hv * (g4*dr(iv) + g2*ds(iv) + g6*dt(iv))
        tmpt(iv) = hv * (g5*dr(iv) + g6*ds(iv) + g3*dt(iv))
      enddo
      enddo
      enddo
      enddo
      enddo
      enddo
      call mxm (drt,np,tmpr,np,lbe,np) ! np x np
      call mxm (dst,np,tmps,np,wrk,np) !
      call add2(lbe,wrk,np*np)         ! add to lbe
      call mxm (dtt,np,tmpt,np,wrk,np) !
      call add2(lbe,wrk,np*np)         ! add to lbe

c     write(6,*) 'lb 0',(lbe(i,1,1,1,1,1),i=1,np*np)

      do q=1,n
      do p=1,n
      do o=1,n
      do k=1,n
      do j=1,n
      do i=1,n
        cr = co(1,i,j,k)
        cs = co(2,i,j,k)
        cs = co(3,i,j,k)
        iv = i + (j-1)*n + (k-1)*n2 + (o-1)*np + (p-1)*np*n
     $                                         + (q-1)*np*n2
        lbe(i,j,k,o,p,q) = lbe(i,j,k,o,p,q)
     $   + cr * dr(iv) + cs * ds(iv) + ct*dt(iv)

      enddo
      enddo
      enddo
      enddo
      enddo
      enddo

c     write(6,*) 'lb 1',(lbe(i,1,1,1,1,1),i=1,np*np)

      call lbe_bdry_3d_l(lbe,lbx,rbx,lby,rby,lbz,rbz
     $     ,h1,gf,bm,co,dr,ds,dt,drt,dst,dtt,ng,nc,nl,l,ie)
c     write(6,*) 'lb 2',(lbe(i,1,1,1,1,1),i=1,np*np)
c     call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine lbe_bdry_3d_l(lbe,lbr,rbr,lbs,rbs,lbt,rbt
     $           ,h1,gf,bm,co,dr,ds,dt,drt,dst,dtt,ng,nc,n,l,ie)

      include 'SIZE'
      include 'GEOM'
      include 'WZ'
      include 'HSMGL'
      integer ng, nc, n, l, ie
      real    lbe(n,n,n,n,n,n)
      real    tmp(n*n*n,n*n*n)
      real    co(nc,n,n,n), h1(n,n,n), gf(ng,n,n,n), bm(n*n*n)
      real    dr(n,n,n,n,n), ds(n,n,n,n,n)
     $      , drt(n,n,n,n,n), dst(n,n,n,n,n)
     $      , dt(n,n,n,n,n), dtt(n,n,n,n,n)

      integer lbr, rbr, lbs, rbs, lbt, rbt
      integer icase(26) ! 6 + 12 + 8 = 26
      real    mas
      real    tmpr(n*n*n), tmps(n*n*n)
      integer pm

      ! in 3D this is a nightmare
      call izero(icase,26) ! 6 sides, 12 edges, 8 points

      ! faces
      if(lbr.eq.0) icase(1) = 1
      if(rbr.eq.0) icase(2) = 1
      if(lbs.eq.0) icase(3) = 1
      if(rbs.eq.0) icase(4) = 1
      if(lbt.eq.0) icase(5) = 1
      if(rbt.eq.0) icase(6) = 1

      ! edges
      icase( 7) = icase(1)*icase(3)
      icase( 8) = icase(1)*icase(4)
      icase( 9) = icase(2)*icase(3)
      icase(10) = icase(2)*icase(4)
      icase(11) = icase(3)*icase(5)
      icase(12) = icase(4)*icase(5)
      icase(13) = icase(3)*icase(6)
      icase(14) = icase(4)*icase(6)
      icase(15) = icase(1)*icase(5)
      icase(16) = icase(1)*icase(6)
      icase(17) = icase(2)*icase(5)
      icase(18) = icase(2)*icase(6)

      ! points
      icase(19) = icase(1)*icase(3)*icase(5)
      icase(20) = icase(1)*icase(4)*icase(5)
      icase(21) = icase(2)*icase(3)*icase(5)
      icase(22) = icase(2)*icase(4)*icase(5)
      icase(23) = icase(1)*icase(3)*icase(6)
      icase(24) = icase(1)*icase(4)*icase(6)
      icase(25) = icase(2)*icase(3)*icase(6)
      icase(26) = icase(2)*icase(4)*icase(6)

      np = n*n*n
      n2 = n*n
      zr = 0.
      call rzero(tmp,np*np)

      do ni=1,6
        if(icase(ni).eq.1) then ! need assemble
          if(ni.eq.1) then
            istart = 1
            jstart = 1
            iskip  = n
            jskip  = n
            idsrc  = n - 1
            jdsrc  = n - 1
          elseif(ni.eq.2) then
            istart = n
            jstart = n
            iskip  = n
            jskip  = n
            idsrc  = - n + 1
            jdsrc  = - n + 1
          elseif(ni.eq.3) then
            istart = 1
            jstart = 1
            iskip  = 1
            jskip  = 1
            idsrc  =   np - n
            jdsrc  =   np - n
          elseif(ni.eq.4) then
            istart = np-n+1
            jstart = np-n+1
            iskip  = 1
            jskip  = 1
            idsrc  = - np + n
            jdsrc  = - np + n
          endif
c         do jj=1,n
c         do ii=1,n
c           i = istart + (ii-1)*iskip
c           j = jstart + (jj-1)*jskip
c           isrc = i + idsrc
c           jsrc = j + jdsrc
c           cr = co(1,i,1)
c           cs = co(2,i,1)
c           tmp(i,j) = tmp(i,j) + cr*dr(isrc,1,jsrc,1)
c    $                          + cs*ds(isrc,1,jsrc,1)
c           do k=1,np
c             tmpr(k) = ( gf(1,k,1)*dr(k,1,jsrc,1)
c    $                +   gf(3,k,1)*ds(k,1,jsrc,1) ) * h1(i,1)
c             tmps(k) = ( gf(3,k,1)*dr(k,1,jsrc,1)
c    $                +   gf(2,k,1)*ds(k,1,jsrc,1) ) * h1(i,1)
c           enddo
c           vdr = vlsc2(dr(1,1,isrc,1),tmpr,np)
c           vds = vlsc2(ds(1,1,isrc,1),tmps,np)
c           tmp(i,j) = tmp(i,j) + (vdr + vds)
c         enddo
c         enddo
        endif
      enddo

      do ni=7,18
      enddo

      do ni=19,26
      enddo

c     do ni=7,18
c     if(icase(ni).eq.1) then !
c       if(ni.eq.5) then
c         i = 1
c       elseif(ni.eq.6) then
c         i = np - n + 1
c       elseif(ni.eq.7) then
c         i = n
c       elseif(ni.eq.8) then
c         i = np
c       endif
c       isrc = np - i + 1
c       cr = co(1,i,1)
c       cs = co(2,i,1)
c       tmp(i,i) = tmp(i,i) + cr*dr(isrc,1,isrc,1)
c    $                      + cs*ds(isrc,1,isrc,1)
c       do k=1,np
c         tmpr(k) = ( gf(1,k,1)*dr(k,1,isrc,1)
c    $            +   gf(3,k,1)*ds(k,1,isrc,1) ) * h1(i,1)
c         tmps(k) = ( gf(3,k,1)*dr(k,1,isrc,1)
c    $            +   gf(2,k,1)*ds(k,1,isrc,1) ) * h1(i,1)
c       enddo
c       vdr = vlsc2(dr(1,1,isrc,1),tmpr,np)
c       vds = vlsc2(ds(1,1,isrc,1),tmps,np)
c       tmp(i,i) = tmp(i,i) + (vdr + vds)
c     endif
c     enddo

c     call add2(lbe,tmp,np*np) ! big

c     write(6,*) 'lbea',(lbe(i,1,1,1,1,1),i=1,np*np)

      ! make use of the existing mask
      pm = p_mg_msk(l,mg_fld) ! starting loc for each elem
      im = mg_imask(pm+ie-1)  ! move by elem number
      nm = mg_imask(pm+im-1)  ! number of Dirichlet noes
      do i=1,nm
        nr = mg_imask(pm+im+i-1) - (ie-1)*np
c       write(6,*) i,nm,nr,im,pm,l,'bunch'
        call mat_setrow(lbe,np,nr,zr)
        call mat_setcol(lbe,np,nr,zr)
        lbe(nr,1,1,nr,1,1) = 1.
      enddo
c     write(6,*) 'lbeb',(lbe(i,1,1,1,1,1),i=1,np*np)
c     call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe_2d_l(lbe,lbx,rbx,lby,rby
     $                               ,h1,gf,bm,co,ng,nc,l,nl,ie)
      include 'SIZE'
      include 'GEOM' ! rxm1, jacm1
      include 'WZ'   ! w3m1
      include 'DXYZ' ! dxm1
      include 'HSMGL' ! mg_dh

      integer l,nl,nc,ng,ie,i,j,p,q
      integer lbx,rbx,lby,rby
      real    lbe(nl,nl,nl,nl) ! build array

      real    h1(nl,nl), bm(nl,nl)
      real    gf(ng,nl,nl), co(nc,nl,nl)

      common /adfscr/ dr, drt, ds, dst, tmpr, tmps, wrk
      real    dr  (lx1*lx1*lx1*lx1) , drt (lx1*lx1*lx1*lx1)
     $      , ds  (lx1*lx1*lx1*lx1) , dst (lx1*lx1*lx1*lx1)
     $      , tmpr(lx1*lx1*lx1*lx1) , tmps(lx1*lx1*lx1*lx1)    
     $      , wrk (lx1*lx1*lx1*lx1)

      ! coefficients
      real    mas

      n    = nl    ! 1D points
      np   = n*n ! number of points

      call gen_iden(wrk,n)
      call kron2(dr,wrk,n,n,mg_dh(1,l),n,n) ! Dr
      call kron2(ds,mg_dh(1,l),n,n,wrk,n,n) ! Ds

      call rzero(lbe,n*n*n*n)
      do q=1,n
      do p=1,n
      do j=1,n
      do i=1,n
        hv = h1(i,j)
        ij = i + (j-1)*n
        iv = i + (j-1)*n + (p-1)*n*n + (q-1)*n*n*n
        g1 = gf(1,i,j)
        g2 = gf(2,i,j)
        g3 = gf(3,i,j)
        tmpr(iv) = hv* (g1*dr(iv) + g3*ds(iv))
        tmps(iv) = hv* (g3*dr(iv) + g2*ds(iv))
      enddo
      enddo
      enddo
      enddo

      call transpose(drt,np,dr,np)
      call transpose(dst,np,ds,np)
      call mxm(drt,np,tmpr,np,lbe,np) ! np x np
      call mxm(dst,np,tmps,np,wrk,np) !
      call add2(lbe,wrk,np*np)        ! add to lbe

      ! keep the advection as is for now
      do q=1,n
      do p=1,n
      do j=1,n
      do i=1,n
c       u1 = ux(i,j)
c       u2 = uy(i,j)
c       cr = (u1*rxm1(i,j,1,ie) + u2*rym1(i,j,1,ie))
c       cs = (u1*sxm1(i,j,1,ie) + u2*sym1(i,j,1,ie))
c       mas = w3m1(i,j,1)
        cr = co(1,i,j)
        cs = co(2,i,j)
        iv = i + (j-1)*n + (p-1)*n*n + (q-1)*n*n*n
        lbe(i,j,p,q) = lbe(i,j,p,q)
     $   + cr * dr(iv) + cs * ds(iv)
c     if(ie.eq.6) 
c    $   write(6,*) l,i,j,p,q,cr,cs,'adv coef'
      enddo
      enddo
      enddo
      enddo

      ! figure out boundary conditions
      call lbe_bdry_2d_l(lbe,lbx,rbx,lby,rby
     $                  ,h1,gf,bm,co,dr,ds,drt,dst,ng,nc,nl,l,ie)

      return
      end
c-----------------------------------------------------------------------
      subroutine lbe_bdry_2d_l(lbe,lbr,rbr,lbs,rbs
     $                  ,h1,gf,bm,co,dr,ds,drt,dst,ng,nc,n,l,ie)
      ! assemble
      include 'SIZE'
      include 'GEOM'
      include 'WZ'
      include 'HSMGL'
      integer ng, nc, n, l, ie
      real    lbe(n,n,n,n)
      real    tmp(n*n,n*n)
      real    co(nc,n,n), h1(n,n), gf(ng,n,n), bm(n*n)
      real    dr(n,n,n,n), ds(n,n,n,n)
     $      , drt(n,n,n,n), dst(n,n,n,n)
      integer lbr, rbr, lbs, rbs
      integer icase(8) ! save this into one array
      real    mas
      real    tmpr(n*n), tmps(n*n)
      integer pm

      ! in 3D this will be a nightmare
      call izero(icase,8) ! 8 cases, 4 sides, 4 points
      if(lbr.eq.0) icase(1) = 1
      if(rbr.eq.0) icase(2) = 1
      if(lbs.eq.0) icase(3) = 1
      if(rbs.eq.0) icase(4) = 1
      icase(5) = icase(1)*icase(3) ! 1 when both sides are 1
      icase(6) = icase(1)*icase(4) ! 1 when both sides are 1
      icase(7) = icase(2)*icase(3) ! 1 when both sides are 1
      icase(8) = icase(2)*icase(4) ! 1 when both sides are 1

      nl = n*n
      zr = 0.
      call rzero(tmp,nl*nl)

      do ni=1,4
        if(icase(ni).eq.1) then ! need assemble
          if(ni.eq.1) then
            istart = 1
            jstart = 1
            iskip  = n
            jskip  = n
            idsrc  = n - 1
            jdsrc  = n - 1
          elseif(ni.eq.2) then
            istart = n
            jstart = n
            iskip  = n
            jskip  = n
            idsrc  = - n + 1
            jdsrc  = - n + 1
          elseif(ni.eq.3) then
            istart = 1
            jstart = 1
            iskip  = 1
            jskip  = 1
            idsrc  =   nl - n
            jdsrc  =   nl - n
          elseif(ni.eq.4) then
            istart = nl-n+1
            jstart = nl-n+1
            iskip  = 1
            jskip  = 1
            idsrc  = - nl + n
            jdsrc  = - nl + n
          endif
          do jj=1,n
          do ii=1,n
            i = istart + (ii-1)*iskip
            j = jstart + (jj-1)*jskip
            isrc = i + idsrc
            jsrc = j + jdsrc
            cr = co(1,i,1)
            cs = co(2,i,1)
            tmp(i,j) = tmp(i,j) + cr*dr(isrc,1,jsrc,1)
     $                          + cs*ds(isrc,1,jsrc,1)
            do k=1,nl
              tmpr(k) = ( gf(1,k,1)*dr(k,1,jsrc,1)
     $                +   gf(3,k,1)*ds(k,1,jsrc,1) ) * h1(i,1)
              tmps(k) = ( gf(3,k,1)*dr(k,1,jsrc,1)
     $                +   gf(2,k,1)*ds(k,1,jsrc,1) ) * h1(i,1)
            enddo
            vdr = vlsc2(dr(1,1,isrc,1),tmpr,nl)
            vds = vlsc2(ds(1,1,isrc,1),tmps,nl)
            tmp(i,j) = tmp(i,j) + (vdr + vds)
c           if(ie.eq.6) then
c             write(6,*) i,j,isrc,jsrc,ni,mas,cr,cs,lbe(isrc,1,jsrc,1)
c    $                  ,'check asmb'
c           endif
          enddo
          enddo
        endif
      enddo

      do ni=5,8
      if(icase(ni).eq.1) then !
        if(ni.eq.5) then
          i = 1
        elseif(ni.eq.6) then
          i = nl - n + 1
        elseif(ni.eq.7) then
          i = n
        elseif(ni.eq.8) then
          i = nl
        endif
        isrc = nl - i + 1
        cr = co(1,i,1)
        cs = co(2,i,1)
        tmp(i,i) = tmp(i,i) + cr*dr(isrc,1,isrc,1)
     $                      + cs*ds(isrc,1,isrc,1)
        do k=1,nl
          tmpr(k) = ( gf(1,k,1)*dr(k,1,isrc,1)
     $            +   gf(3,k,1)*ds(k,1,isrc,1) ) * h1(i,1)
          tmps(k) = ( gf(3,k,1)*dr(k,1,isrc,1)
     $            +   gf(2,k,1)*ds(k,1,isrc,1) ) * h1(i,1)
        enddo
        vdr = vlsc2(dr(1,1,isrc,1),tmpr,nl)
        vds = vlsc2(ds(1,1,isrc,1),tmps,nl)
        tmp(i,i) = tmp(i,i) + (vdr + vds)
      endif
      enddo

      call add2(lbe,tmp,nl*nl) ! big

      ! make use of the existing mask
      pm = p_mg_msk(l,mg_fld) ! starting loc for each elem

c     do il=1,mg_lmax
c       write(6,*) 'levl starting',il,p_mg_msk(il,mg_fld)
c     enddo

c     write(6,*) 'pm',pm
c     do ie=1,nelt
c       im = mg_imask(pm+ie-1)
c       nm = mg_imask(pm+im-1)
c       write(6,*) 'mg e',ie,im,nm
c       do i=1,nm
c         write(6,*) 'indx',i,nm,mg_imask(pm+im-1+i)-(ie-1)*nl
c       enddo
c     enddo
c     call exitt

      im = mg_imask(pm+ie-1)  ! move by elem number
      nm = mg_imask(pm+im-1)  ! number of Dirichlet noes
      do i=1,nm
        nr = mg_imask(pm+im+i-1) - (ie-1)*nl
c       write(6,*) i,nm,nr,im,pm,'bunch'
        call mat_setrow(lbe,nl,nr,zr)
        call mat_setcol(lbe,nl,nr,zr)
        lbe(nr,1,nr,1) = 1.
      enddo

c     do j=1,n
c     do i=1,n
c       ij = i + (j-1)*n
c       if(rmsk(ij,ie).lt.0.5) then
c         write(6,*) ij,ie,'flagged to be bdry'
c         call mat_setrow(lbe,nl,ij,zr) ! the ij-th row
c         call mat_setcol(lbe,nl,ij,zr) ! the ij-th col
c         lbe(ij,1,ij,1) = 1.           ! diag term
c       endif
c     enddo
c     enddo
c     write(6,*) lx1,lbr,rbr,lbs,rbs,'what'

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_schwzmn_wt_1(wt,l,ifsqrt)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'TSTEP'  ! ifield
      include 'HSMGL'

      real wt(1),work(1)
      logical ifsqrt

      integer enx,eny,enz,pm

      zero =  0
      one  =  1
      onem = -1

      n  = mg_h1_n (l,mg_fld)
      pm = p_mg_msk(l,mg_fld)

      enx=mg_nh(l) ! no extrusion
      eny=mg_nh(l)
      enz=mg_nh(l)
      if(.not.if3d) enz=1
      ns = enx*eny*enz*nelfld(mg_fld)

      call rone(mg_work,ns)
      call adfmg_dssum(mg_work,l)                           ! sum border nodes

c     write(6,*) n,l,'n, l'
c     write(6,*) 'wt 1',(mg_work(j),j=1,n)

      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nh(l)
      if (.not.if3d) nz=1
      nxyz = nx*ny*nz
      k    = 1
      do ie=1,nelfld(ifield)
c        call outmat(mg_work(k),nx,ny,'NEW WT',ie)
         call adfmg_setup_schwzmn_wt_2(wt,ie,nx,mg_work(k),ifsqrt)
         k = k+nxyz
      enddo

c     do ie=1,nelt
c       j0 = 1 + (ie-1)*4*2*nx
c       write(6,*) 'wt 2',(wt(j),j=j0,j0+4*nx*2-1)
c     enddo
c     stop

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_setup_schwzmn_wt_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      real wt(1),work(1)
      logical ifsqrt

      if(ldim.eq.2) call adfmg_setup_schwzmn_wt2d_2(wt,ie,n,work
     $                                             ,ifsqrt)
      if(ldim.eq.3) call adfmg_setup_schwzmn_wt3d_2(wt,ie,n,work
     $                                             ,ifsqrt)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_schwzmn_wt2d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,4,2,nelt)
      real work(n,n)
      
      integer ie,i,j
      do j=1,n
         wt(j,1,1,ie)=1.0/work(1,j)
         wt(j,2,1,ie)=1.0/work(2,j)
         wt(j,3,1,ie)=1.0/work(n-1,j)
         wt(j,4,1,ie)=1.0/work(n,j)
      enddo
      do i=1,n
         wt(i,1,2,ie)=1.0/work(i,1)
         wt(i,2,2,ie)=1.0/work(i,2)
         wt(i,3,2,ie)=1.0/work(i,n-1)
         wt(i,4,2,ie)=1.0/work(i,n)
      enddo
      if(ifsqrt) then
         do ii=1,2
         do j=1,4
         do i=1,n
            wt(i,j,ii,ie)=sqrt(wt(i,j,ii,ie))
         enddo
         enddo
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_schwzmn_wt3d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,n,4,3,nelt)
      real work(n,n,n)
      
      integer ie,i,j,k
      integer lbr,rbr,lbs,rbs,lbt,rbt

      ierr = 0
      do k=1,n
      do j=1,n
         wt(j,k,1,1,ie)=1.0/work(1,j,k)
         wt(j,k,2,1,ie)=1.0/work(2,j,k)
         wt(j,k,3,1,ie)=1.0/work(n-1,j,k)
         wt(j,k,4,1,ie)=1.0/work(n,j,k)
      enddo
      enddo
      do k=1,n
      do i=1,n
         wt(i,k,1,2,ie)=1.0/work(i,1,k)
         wt(i,k,2,2,ie)=1.0/work(i,2,k)
         wt(i,k,3,2,ie)=1.0/work(i,n-1,k)
         wt(i,k,4,2,ie)=1.0/work(i,n,k)
      enddo
      enddo
      do j=1,n
      do i=1,n
         wt(i,j,1,3,ie)=1.0/work(i,j,1)
         wt(i,j,2,3,ie)=1.0/work(i,j,2)
         wt(i,j,3,3,ie)=1.0/work(i,j,n-1)
         wt(i,j,4,3,ie)=1.0/work(i,j,n)
      enddo
      enddo
      if(ifsqrt) then
         do ii=1,3
         do k=1,4
         do j=1,4
         do i=1,n
            wt(i,j,k,ii,ie)=sqrt(wt(i,j,k,ii,ie))
         enddo
         enddo
         enddo
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_l(e,r,sigma,l) !h1mg_schwarz
      include 'SIZE'
      include 'HSMGL'
      include 'SOLN'

      real    e(1),r(1)
      real    sigma
      integer l
      common /logmn/ ifrstr
      logical        ifrstr

      n  = mg_h1_n(l,mg_fld)
      nh = mg_nh(l)

      call adfmn_schwz_l_part1 (e,r,l) ! !
      if(ifrstr) then
        ! do nothing
        ! write(6,*) 'doing nothing in schwz l RAS path'
      else
        call adfmg_schwarz_wt  (e,l)          ! e  := W e
      endif
      call cmult               (e,sigma,n)    !  l       l

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_l_part1(e,r,l)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'TSTEP'  ! ifield
      include 'HSMGL'
      include 'SOLN'

      real    e(1),r(1)

      integer enx,eny,enz,pmsk
      real    tmp(lx1,ly1,lz1,lelt)
      common /logmn/ ifrstr
      logical        ifrstr

      zero =  0
      one  =  1
      onem = -1

      n  = mg_h1_n (l,mg_fld)
      pmsk = p_mg_msk(l,mg_fld)
      nx = mg_nh(l)

      ifield = 2
      call adfmg_mask (r,mg_imask(pmsk),nelfld(ifield))  ! Zero Dirichlet nodes
      call adfmn_schwzmg_lu(e,r,l,nx) ! Do the local solves

      if(ifrstr) then
        ! write(6,*) 'doing masking in schwz l part 1 RAS path'
        call adfmn_schwz_rs(e,l) !
      endif

      call adfmg_dssum(e,l)                           ! sum border nodes
      call adfmg_mask (e,mg_imask(pmsk),nelfld(ifield)) ! apply mask 

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_rs(u,l) ! apply the weights
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      parameter(lt=lx1*ly1*lz1*lelt)

      common /adfrsm/ ras_mask, wrk
      real            ras_mask(lx1*ly1*lz1*lelt,lmgn)
     $              , wrk(lx1*ly1*lz1*lelt)

      real u(1)
      integer l

      nl = mg_nh(l)

      if(ldim.eq.3) then
        call adf_schwarz_rs3d(u,ras_mask(1,l),nl)
      else
        call adf_schwarz_rs2d(u,ras_mask(1,l),nl)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_schwzmn_wt(ifsqrt)
      logical ifsqrt
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      
      integer l,i,nl,nlz
      common /adfrsm/ ras_mask, wrk
      real            ras_mask(lx1*ly1*lz1*lelt,lmgn)
     $              , wrk(lx1*ly1*lz1*lelt)

      common /logmn/ ifrstr
      logical        ifrstr

      i = mg_schwarz_wt_index(mg_lmax,mg_fld-1)

c     do l=2,mg_lmax
      do l=1,mg_lmax

         mg_schwarz_wt_index(l,mg_fld)=i
         nl  = mg_nh(l)
         nlz = mg_nhz(l)
         i   = i+nl*nlz*4*ldim*nelt

         if (i .gt. lmg_swt*4*ldim*lelt) then
            itmp = i/(4*ldim*lelt)
            write(6,*) 'lmg_swt too small',i,itmp,lmg_swt,l
            call exitt
         endif

         call adfmg_setup_schwzmn_wt_1(
     $      mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),l,ifsqrt)

         if(ifrstr) then
           write(6,*) 'creating ras mask in setup wt',l
           nx = mg_nh(l)
           ny = mg_nh(l)
           nz = mg_nhz(l)
           call adfmn_setup_mask_rt(ras_mask(1,l),nx,ny,nz,l,wrk)
         endif

c        if(nid.eq.0) write(6,*) 'write out ras mask',l
c        call adfmg_outpost(ras_mask(1,l),l)
      enddo

      mg_schwarz_wt_index(l,mg_fld)=i
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_mask_rt_3(wv,nx,ny,nz,l,w) ! No 3D
      include 'SIZE'
      include 'INPUT'
      include 'SOLN' ! for outpost debugging only, remove later
      include 'PARALLEL' ! for outpost debugging only, remove later
      integer nx,ny,nz,l
      real  w(nx,ny,nz,nelt)
      real wv(nx,ny,nz,nelt)

      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      common /logmn/ ifrstr
      logical        ifrstr

      n = nx*ny*nz*nelt
      call rone(w,n)
      call rone(wv,n)

c     set neumann nodes to zero
      ierr = 0
      two  = 2
      do ie=1,nelt
        ! general case
        call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        if (ierr.ne.0) then
           ierr = -1
           call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        endif

          if(lbr.eq.2) then !
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            iz0=2
            if(lbt.eq.2) iz0 = 1
            iz1=nz-1
            if(rbt.eq.2) iz1 = nz
            do k=iz0,iz1
            do j=iy0,iy1
              wv(1,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbr.eq.2) then
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            iz0=2
            if(lbt.eq.2) iz0 = 1
            iz1=nz-1
            if(rbt.eq.2) iz1 = nz
            do k=iz0,iz1
            do j=iy0,iy1
              wv(nx,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(lbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            iz0=2
            if(lbt.eq.2) iz0 = 1
            iz1=nz-1
            if(rbt.eq.2) iz1 = nz
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,1,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            iz0=2
            if(lbt.eq.2) iz0 = 1
            iz1=nz-1
            if(rbt.eq.2) iz1 = nz
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,ny,k,ie) = 0.
            enddo
            enddo
          endif
          if(lbt.eq.2) then
            ix0=2
            if(lbr.eq.2) ix0=1
            ix1=nx-1
            if(lbr.eq.2) ix1=nx
            iy0=2
            if(lbr.eq.2) iy0=1
            iy1=ny-1
            if(lbr.eq.2) iy1=ny
            do j=iy0,iy1
            do i=ix0,ix1
              wv(i,j,1,ie) = 0.
            enddo
            enddo
          endif
          if(rbt.eq.2) then
            ix0=2
            if(lbr.eq.2) ix0=1
            ix1=nx-1
            if(lbr.eq.2) ix1=nx
            iy0=2
            if(lbr.eq.2) iy0=1
            iy1=ny-1
            if(lbr.eq.2) iy1=ny
            do j=iy0,iy1
            do i=ix0,ix1
              wv(i,j,nz,ie) = 0.
            enddo
            enddo
          endif

          ieg = lglel(ie)
          if(ieg.gt.18) then
            write(6,*) 'ie,ieg  ',ie,ieg
            write(6,*) 'wv  ',(wv(i,1,1,ie),i=1,nx*ny*nz)
          endif
      enddo


      call copy(w, wv, n)

c     if(nid.eq.0) write(6,*) 'AA : write out ras mask',l
c     call adfmg_outpost(w,l)

      call adfmg_dssum(w,l) ! summed up

c     if(nid.eq.0) write(6,*) 'AB : write out ras mask',l
c     call adfmg_outpost(w,l)

      do i=1,nx*ny*nz*nelt
        if(w(i,1,1,1).lt.1e-7) then  ! one elem, right=outflow(t field)
          write(6,*) 'Error in rst mask',i,w(i,1,1,1),', set to 1.'
          w (i,1,1,1) = 1.
          wv(i,1,1,1) = 1.
        endif
        w(i,1,1,1) = 1./w(i,1,1,1)
      enddo

c     if(nid.eq.0) write(6,*) 'AC : write out ras mask',l
c     call adfmg_outpost(w,l)

      call col2(wv,w,n) ! zero remains zero, otherwize 1/multiplic

c     if(nid.eq.0) write(6,*) 'AD : write out ras mask',l
c     call adfmg_outpost(w,l)
c     if(l.eq.2) call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_mask_rt_2(wv,nx,ny,nz,l,w) ! No 3D
      include 'SIZE'
      include 'INPUT'
      include 'SOLN' ! for outpost debugging only, remove later!
      integer nx,ny,nz,l
      real  w(nx,ny,nz,nelt)
      real wv(nx,ny,nz,nelt)

      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      common /logmn/ ifrstr
      logical        ifrstr

      n = nx*ny*nz*nelt
      call rone(w,n)
      call rone(wv,n)

c     set neumann nodes to zero
      ierr = 0
      two  = 2
      do ie=1,nelt
        ! general case
        call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        if (ierr.ne.0) then
           ierr = -1
           call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        endif
        sumbc = lbr+rbr+lbs+rbs
        if(sumbc.gt.4)
     $  write(6,*) ie,lbr,rbr,lbs,rbs,' fast bcs'

          iz0 = 1
          iz1 = nz
          if(lbr.eq.2) then !
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(1,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbr.eq.2) then
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(nx,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(lbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,1,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,ny,k,ie) = 0.
            enddo
            enddo
          endif
      enddo
      call copy(w, wv, n)
      call adfmg_dssum(w,l) ! summed up

      do i=1,nx*ny*nz*nelt
        if(w(i,1,1,1).lt.1e-7) then  ! one elem, right=outflow(t field)
          write(6,*) 'Error in rst mask',i,w(i,1,1,1),', set to 1.'
          w (i,1,1,1) = 1.
          wv(i,1,1,1) = 1.
        endif
        w(i,1,1,1) = 1./w(i,1,1,1)
      enddo

      call col2(wv,w,n) ! zero remains zero, otherwize 1/multiplic

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_mask_rt(wv,nx,ny,nz,l,w) ! No 3D
      include 'SIZE'
      include 'INPUT'
      include 'SOLN' ! for outpost debugging only, remove later!
      integer nx,ny,nz,l
      real    w (nx,ny,nz,nelt)
      real    wv(nx,ny,nz,nelt)
      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      if(ldim.eq.2) call adfmn_setup_mask_rt_2(wv,nx,ny,nz,l,w)
      if(ldim.eq.3) call adfmn_setup_mask_rt_3(wv,nx,ny,nz,l,w)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwzmg_lu(x,r,l,nx) !
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      common /adflng/  lb
      real             lb(lx1**2,lx1**2,lelt,lmgn)  ! system to solve
      common /adfilng/ ipiv ! integer array
      integer          ipiv(lx1**2,lelt,lmgn)   ! pivot index

      integer info       ! return information
      real    x(nx**ldim,1), r(nx**ldim,1) ! 3D declaration
      character*1 tr

      integer ilufcd(3)  ! flag for whether already LU factored
      data    ilufcd / 3*0 /
      save    ilufcd

      ns = nx**ldim

      ! only factor once
      tr = 'N' ! no transpose
c     write(6,*) 'r  1',(r(i,1),i=1,ns)
      if(ilufcd(l).eq.0) then
        if(nio.eq.0) write(6,*) 'MG Schwarz(m): LU factoring...',l
        do ie=1,nelt
          ile = 1 + (ie-1)*ns*ns
          call dgetrf(ns,ns,lb(ile,1,1,l),ns,ipiv(1,ie,l),info) ! LU
          if(info.ne.0) write(6,*) 'issue in dgetrf',ie,info,l
          if(info.ne.0) call exitt

          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,lb(ile,1,1,l),ns,ipiv(1,ie,l),x(1,ie)
     $                                                     ,ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie,info
        enddo
        ilufcd(l) = 1
      else if(ilufcd(l).eq.1) then ! already factored, only need to solve
        do ie=1,nelt
          ile = 1 + (ie-1)*ns*ns
          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,lb(ile,1,1,l),ns,ipiv(1,ie,l),x(1,ie)
     $                                                     ,ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie,info,l
        enddo
      endif

      return
      end
c----------------------------------------------------------------------
c---- Minimal overlapping Schwarz
c----------------------------------------------------------------------
      subroutine adf_schwarzmn_tens_test(e,res,sigma,mxit) !
      include 'SIZE'
      include 'HSMGL'
      include 'SOLN'
      parameter(lt=lx1*ly1*lz1*lelt)
      integer l,mxit

      real e(1),res(1)
      real sigma
      real r(lt), w(lt)

      common /adfcoef/ h1(lt)
      real             h1
      common /adfexc/ uex
      real            uex(lt)

      op = 1.
      om = -1.

      n = nx1*ny1*nz1*nelt
      call copy(r,res,n)

      write(6,*) n,'adf_schwarzmn_tens_test: n'
      tol = 1.e-10
      call rzero(e,n)

        call adf_schwarzmn_tens(w,r,sigma,mxit) !!
        call add2         (e,w,n)
        call copy         (r,res,n)
        call adfax        (w,e,h1)
        call sub2         (r,w,n)

        rn = sqrt(glsc2(r,r,n))
        write(6,*) rn,tol,' schwz mn tens test'

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarzmn_tens(x,res,sigma,maxit) ! single+crs
      include 'SIZE'
      include 'TOTAL'

      parameter (lt=lx1*ly1*lz1*lelt)
      real    x(1), res(1), wt(1), u0(1)
      integer iter, maxit
      real    tmp(lt), tmc(lt), r0(lt) ! work array
      integer icalld
      data    icalld / 0 /
      save    icalld

      common /adfexc/ uex
      real            uex(lt)
      common /adfcoef/ h1(lt)
      real             h1
      common /logmn/ ifrstr
      logical        ifrstr

      real     er(lt)

      ifrstr = .true.  ! restricted AS, sub-domain Dir+Neum
      ifrstr = .false. ! weighted AS, sub-domain all Dir

      ngo = -99
      if (istep.le.20.or.mod(istep,10).eq.0) ngo = nio
      n = lx1*ly1*lz1*nelt ! in scalar field
      call rzero(x,n)

      if(icalld.eq.0) then
        if(ifrstr) then
          if(nio.eq.0) write(6,*) 'Restricted AS path'
        else
          if(nio.eq.0) write(6,*) 'AS path'
        endif
        if(nio.eq.0) write(6,*) 'into adf schwzmn setup'
        call adfmn_schwz_setup_tens()
        icalld = 1
        if(nio.eq.0) write(6,*) 'schwzmn: sigma=',sigma
      endif

      ! nontrivial initial guess
      call copy (r0,res,n)
      rn0 = sqrt(glsc2(res,res,n))           ! rnorm
      rn1 = 1.e-10   ! absolute tolerance

      if(maxit.eq.0) maxit = 100 ! default iteration counts
      do iter=1,maxit
        call rzero(tmp,n)
        call adfmn_schwz_part1_tens(tmp,r0,h1) ! solve for x
        if(ifrstr) then ! only turn on for AS
          ! do nothing
        else
          call adfmn_schwz_wt(tmp)     ! x  := W x, interface weight
        endif

        ! update solution
        call add2s2(x,tmp,sigma,n)              ! x = x + dx
        call adfax (tmp,x,h1)
        call sub3  (r0,res,tmp,n) ! r = r0 - A x

        rn = sqrt(glsc2(r0,r0,n))
        if(rn.le.rn1) then
          if(ngo.eq.0) write(6,10)
     $       istep,iter,rn,rn0,rn1
          goto 88
        endif
        if (ngo.eq.0) write(6,9)
     $       istep,iter,rn,rn0,rn1
    9       format(i9,1i5,1p3e12.4,' shwtens')
   10       format(i9,1i5,1p3e12.4,' shwtensb')
        if(mod(iter,1).eq.0) then
          call outpost(vx,vy,vz,pr,x,'   ')
c       call sub3(er,x,uex,n)
c       call col2(er,tmask,n)
c       call outpost(vx,vy,vz,pr,er,'   ')
        endif
      enddo
   88 CONTINUE

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_schwz_setup_tens()
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'
      include 'SEMHAT'

      common /fastmd/ ifdfrm(lelt), iffast(lelt), ifsolv
      logical  ifdfrm, iffast, ifh2, ifsolv

      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common  /adfmmsk/ rmsk
      real              rmsk(lx1**ldim,lelt)

      integer e

      integer icall
      save    icall
      data    icall /0/

      write(6,*) 'adf: schwzmn_setup',icall,ifield
      icall = icall+1
      if (icall.gt.10) stop

      param(59) = 1
      do e=1,nelt
         ifdfrm(e)=.true.
      enddo
      call geom_reset(1)  ! Recompute g1m1 etc. with deformed only

      n = lx1*ly1*lz1*nelt

      write(6,*) 'adf schwz mn setup :: into setup semhat'
      call adf_swap_lengths   ! need to have lengths before build
      call adf_swap_lengths_fix  ! hack so that no lengths are 0

      write(6,*) 'adf schwz mn setup :: into setup semhat'
      call adfs_setup_semhat ! SEM hat matrices for one level

      write(6,*) 'adf schwz mn setup :: into setup dssum'
      call adfmn_setup_dssum  ! ! set direct stiffness summation handles

      write(6,*) 'adf schwz mn setup :: into setup wtmask'
      call adf_setup_wtmask() ! set restriction weight matrices and bc masks

      write(6,*) 'adf schwz mn setup :: into setup schwarz wt'
      call adfmn_setup_schwz_wt(.false.) ! another weight mask?

      write(6,*) 'adf schwz mn setup :: into setup rmask'
      call adfmn_setup_rmask(rmsk)

      write(6,*) 'adf schwz mn setup :: into build lb'
      call adfmn_schwz_tens_gen() ! ! build element local matrices

      write(6,*) 'adf schwz mn setup :: done'
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_part1_tens(e,r,h1)
      include 'SIZE'
      include 'TOTAL'

      common /logmn/  ifrstr
      logical         ifrstr

      real    e(1),r(1), h1(1)
      real    tmp(lx1*ly1*lz1*lelt)

      n  = lx1
      nt = lx1*ly1*lz1*nelt

      call col2(r, tmask(1,1,1,1,1), nt)

      call adfmn_maskr(r) ! need: mask rhs using elem local bc

      call adfmn_schwz_tens_solve(e,r) ! Do the local solves

      if(ifrstr) then ! before dssum do restrictive mask
        ! write(6,*) 'into schwarz rs'
        call adf_schwz_rs(e)
      endif
      call adf_dssum(e)
      call col2(e, tmask(1,1,1,1,1), nt)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_wt(e) ! apply the weights
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      parameter(lt=lx1*ly1*lz1*lelt)
      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)

      real e(1)

      if(.not.if3d) call adfmn_schwz_wt2d(e,oswt,lx1)
      if(if3d)      call adfmn_schwz_wt3d(e,oswt,lx1)
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_wt2d(e,wt,n) !
      include 'SIZE'
      integer n
      real e(n,n,nelt)
      real wt(n,4,2,nelt)
      integer ie,i,j
      do ie=1,nelt
         do j=1,n
            e(1  ,j,ie)=e(1  ,j,ie)*wt(j,1,1,ie)
            e(2  ,j,ie)=e(2  ,j,ie)*wt(j,2,1,ie)
            e(n-1,j,ie)=e(n-1,j,ie)*wt(j,3,1,ie)
            e(n  ,j,ie)=e(n  ,j,ie)*wt(j,4,1,ie)
         enddo
         do i=3,n-2
            e(i,1  ,ie)=e(i,1  ,ie)*wt(i,1,2,ie)
            e(i,2  ,ie)=e(i,2  ,ie)*wt(i,2,2,ie)
            e(i,n-1,ie)=e(i,n-1,ie)*wt(i,3,2,ie)
            e(i,n  ,ie)=e(i,n  ,ie)*wt(i,4,2,ie)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_wt3d(e,wt,n) !
      include 'SIZE'
      integer n
      real e(n,n,n,nelt)
      real wt(n,n,4,3,nelt)
      integer ie,i,j,k
      do ie=1,nelt
         do k=1,n
         do j=1,n
            e(1  ,j,k,ie)=e(1  ,j,k,ie)*wt(j,k,1,1,ie)
            e(2  ,j,k,ie)=e(2  ,j,k,ie)*wt(j,k,2,1,ie)
            e(n-1,j,k,ie)=e(n-1,j,k,ie)*wt(j,k,3,1,ie)
            e(n  ,j,k,ie)=e(n  ,j,k,ie)*wt(j,k,4,1,ie)
         enddo
         enddo
         do k=1,n
         do i=3,n-2
            e(i,1  ,k,ie)=e(i,1  ,k,ie)*wt(i,k,1,2,ie)
            e(i,2  ,k,ie)=e(i,2  ,k,ie)*wt(i,k,2,2,ie)
            e(i,n-1,k,ie)=e(i,n-1,k,ie)*wt(i,k,3,2,ie)
            e(i,n  ,k,ie)=e(i,n  ,k,ie)*wt(i,k,4,2,ie)
         enddo
         enddo
         do j=3,n-2
         do i=3,n-2
            e(i,j,1  ,ie)=e(i,j,1  ,ie)*wt(i,j,1,3,ie)
            e(i,j,2  ,ie)=e(i,j,2  ,ie)*wt(i,j,2,3,ie)
            e(i,j,n-1,ie)=e(i,j,n-1,ie)*wt(i,j,3,3,ie)
            e(i,j,n  ,ie)=e(i,j,n  ,ie)*wt(i,j,4,3,ie)
         enddo
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_tens_solve(x,r) !
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      common /adftens/ L (lx1,ly1,lelt)
     $               , V1(lx1,lx1,lelt), W1(lx1,lx1,lelt)
     $               , V2(ly1,ly1,lelt), W2(ly1,ly1,lelt)
      complex*16       L, V1, V2, W1, W2

      real    x(lx1**ldim,1), r(lx1**ldim,1) ! 3D declaration
      integer e

      do e=1,nelt
c        Solve with fast tensor product preconditioner
         call fdm_2d_solve(lx1,ly1,x(1,e),L(1,1,e),
     $        V1(1,1,e),V2(1,1,e),W1(1,1,e),W2(1,1,e),r(1,e))
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_maskr(r) !
      include 'SIZE'
      include 'SOLN'

      real    r(lx1**ldim,1) ! 3D declaration

      common  /adfmmsk/ rmsk
      real              rmsk(lx1**ldim,lelt)

      ns  = lx1**ldim
      do ie=1,nelt
        call col2(r(1,ie),rmsk(1,ie),ns)
      enddo
c     call outpost(vx,vy,vz,pr,rmsk,'   ')
c     call outpost(vx,vy,vz,pr,r,'   ')
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_rmask(rm) !
      include 'SIZE'

      real    rm(lx1**ldim,1) ! 3D declaration
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      two    = 2
      zero   = 0
      ierr   = 0
      ierrmx = 0
      ifield = 2
      nx     = lx1
      ny     = ly1
      nz     = lz1
      ns     = lx1**ldim

      call rone(rm,ns*nelt)

      do ie=1,nelt
        call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        if(lbr.eq.1) call facev(rm,ie,4,zero,nx,ny,nz)
        if(rbr.eq.1) call facev(rm,ie,2,zero,nx,ny,nz)
        if(lbs.eq.1) call facev(rm,ie,1,zero,nx,ny,nz)
        if(rbs.eq.1) call facev(rm,ie,3,zero,nx,ny,nz)
        if(ldim.eq.3) then
          if(lbt.eq.1) call facev(rm,ie,5,zero,nx,ny,nz)
          if(rbt.eq.1) call facev(rm,ie,6,zero,nx,ny,nz)
        endif
        ierrmx = max(ierrmx,ierr)
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_lu(x,r) !
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      common /adfscbn/ lb
      real             lb(lx1**ldim,lx1**ldim,lelt)  ! system to solve
      common /adfiarn/ ipiv ! integer array
      integer          ipiv(lx1**ldim,lelt)   ! pivot index

      integer info       ! return information
      real    x(lx1**ldim,1), r(lx1**ldim,1) ! 3D declaration
      character*1 tr

      integer ilufcd  ! flag for whether already LU factored
      data    ilufcd / 0 /
      save    ilufcd

      ns  = lx1**ldim

      ! only factor once
      tr = 'N' ! no transpose
c     write(6,*) 'r  1',(r(i,1),i=1,ns)
      if(ilufcd.eq.0) then
        if(nio.eq.0) write(6,*) 'Schwarz: LU factoring...'
        do ie=1,nelt
          call dgetrf(ns,ns,lb(1,1,ie),ns,ipiv(1,ie),info) ! LU
          if(info.ne.0) write(6,*) 'issue in dgetrf',ie

          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,lb(1,1,ie),ns,ipiv(1,ie),x(1,ie),ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie
        enddo
        ilufcd = 1
      else if(ilufcd.eq.1) then ! already factored, only need to solve
        do ie=1,nelt
          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,lb(1,1,ie),ns,ipiv(1,ie),x(1,ie),ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie
        enddo
      endif
c     write(6,*) 'x  1',(x(i,1),i=1,ns)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_dssum
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'HSMGL'
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)

      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l

      common /adfsci/ adfsc_handle, t_handle
      integer         adfsc_handle, t_handle

      ! need this, should work
      ncrnr = 2**ldim
      call get_vert

      nx=nx1 !+2
      ny=ny1 !+2
      nz=nz1 !+2
      if(.not.if3d) nz=1
      call setupds(adfsc_handle,nx,ny,nz
     $                ,nelt,nelgt,vertex,glo_num)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_tens_gen ! minimal overlap
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'

      include 'SOLN' ! to vx, vy, vz
      include 'GEOM'
      integer i,j,nl,e
      common /adfscbn/ lb
      real             lb(lx1**ldim,lx1**ldim,lelt) ! each element
      common /adftens/ L (lx1,ly1,lelt)
     $               , V1(lx1,lx1,lelt), W1(lx1,lx1,lelt)
     $               , V2(ly1,ly1,lelt), W2(ly1,ly1,lelt)
      complex*16       L, V1, V2, W1, W2
      integer lbr,rbr,lbs,rbs,lbt,rbt,two,bcs(6,lelt)
      integer ierr
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /adfscr/  A(lx1,lx1,3), B(ly1,ly1,3)
      real             A, B

c     ibc = 0  <==>  Dirichlet, with extension
c     ibc = 1  <==>  Dirichlet, no extension, for boundaries
c     ibc = 2  <==>  Neumann,  domain boundary
c     ibc = 3  <==>  Neumann,  element boundary

      nxyz = nx1*ny1*nz1
      
      do e=1,nelt
         ifield = 2
         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,e,two,ierr)
c        write(6,*) e,lbr,rbr,lbs,rbs,'bc s '
         bcs(1,e)=lbr
         bcs(2,e)=rbr
         bcs(3,e)=lbs
         bcs(4,e)=rbs
         bcs(5,e)=lbt
         bcs(6,e)=rbt
      enddo

      call adf_tens_gen(bcs)

      two  = 2
      ierr = 0
      i = 1
      do e=1,nelt
c     Compute tensor product approximation kron(B1,A1)+kron(B2,A2)
         call adf_tens_svd(e,A,B)
c     Solve 1d generalized eigenproblems
         call fdm_2d(lx1,ly1,L(1,1,e),
     $        V1(1,1,e),V2(1,1,e),W1(1,1,e),W2(1,1,e),A,B,bcs(1,e))
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_schwz_buildlb ! minimal overlap
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'

      include 'SOLN' ! to vx, vy, vz
      include 'GEOM'
      integer l,i,j,nl
      common /adfscbn/ lb
      real             lb(lx1**ldim,lx1**ldim,lelt) ! each element
      integer lbr,rbr,lbs,rbs,lbt,rbt,two
      integer ierr
      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      common /adflf/  lr(2*lx1+4),ls(2*lx1+4),lt(2*lx1+4)
     $              , llr(lelt),lls(lelt),llt(lelt)
     $              , lmr(lelt),lms(lelt),lmt(lelt)
     $              , lrr(lelt),lrs(lelt),lrt(lelt)
      real lr ,ls ,lt
      real llr,lls,llt
      real lmr,lms,lmt
      real lrr,lrs,lrt

c     write(6,*) 'build lb: before printing l'
c     do ie=1,nelt
c     write(6,*) ie,llr(ie),lmr(ie),lrr(ie),lls(ie),lms(ie),lrs(ie),'l'
c     enddo

      nxyz = nx1*ny1*nz1

      two  = 2
      ierr = 0
      i = 1
      do ie=1,nelt

         ifield = 2
         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
c        write(6,*) 'elem # = ',ie,lbr,rbr,lbs,rbs
         call adfmn_build_lbe(Lb(1,1,ie),lbr,rbr,lbs,rbs,lbt,rbt
     $        ,llr(ie),lmr(ie),lrr(ie),lls(ie),lms(ie),lrs(ie)
     $        ,llt(ie),lmt(ie),lrt(ie),h1(i)
     $        ,vx(1,1,1,ie),vy(1,1,1,ie),vz(1,1,1,ie)
     $        ,ie)
         i = i + nxyz ! increase with element count
c        write(6,*) 'finished building one matrix',i,ie
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe(lbe,lbx,rbx,lby,rby,lbz,rbz
     $           ,llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz,h1
     $           ,ux,uy,uz,ie)
      include 'SIZE'

      integer lbx,rbx,lby,rby,lbz,rbz
      real    lbe(1) ! build array
      real    llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz

      integer i,j,i0,i1
      real    h1(1) ! starting from the element count
      real    ux(1), uy(1), uz(1)

      if(ldim.eq.3) then
        call adfmn_build_lbe_3d(lbe,lbx,rbx,lby,rby,lbz,rbz
     $           ,llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz,h1
     $           ,ux,uy,uz,ie)
      else
        call adfmn_build_lbe_2d(lbe,lbx,rbx,lby,rby
     $           ,llx,lmx,lrx,lly,lmy,lry,h1
     $           ,ux,uy,ie)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe_3d(Lbe,lbx,rbx,lby,rby,lbz,rbz
     $           ,llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz,h1
     $           ,ux,uy,uz,ie)
      include 'SIZE'
      parameter(ls=lx1)

      integer lbx,rbx,lby,rby,lbz,rbz
      real    Lbe(ls,ls,ls,ls,ls,ls) ! build array, 3D

      real    llx,lmx,lrx,lly,lmy,lry,llz,lmz,lrz

      real    ax(ls,ls), bx(ls,ls), cx(ls,ls)
     $     ,  ay(ls,ls), by(ls,ls), cy(ls,ls)
     $     ,  az(ls,ls), bz(ls,ls), cz(ls,ls)

      real    us(ls,ls,ls), vs(ls,ls,ls), ws(ls,ls,ls)

      integer i,j,i0,i1, k,l,p,q
      real    h1(lx1,ly1,lz1) ! starting from the element count
      real    ux(lx1,ly1,lz1), uy(lx1,ly1,lz1), uz(lx1,ly1,lz1)

      n = ls

      return
      end
c-----------------------------------------------------------------------
      subroutine kron2(c,a,ia,ja,b,ib,jb)
      include 'SIZE'

c     C = kron(A,B)

      real    c(ib,ia,jb,ja)
      real    a(ia,ja)
      real    b(ib,jb)

      integer i,j,k,l


      call rzero(c,ia*ja*ib*jb)
      do l=1,ja
      do k=1,jb
      do j=1,ia
      do i=1,ib
        c(i,j,k,l) = a(j,l) * b(i,k)
      enddo
      enddo
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine mat_setcol(a,na,ja,c)
      include 'SIZE'
c     set col ja of matrix a to c
      integer na, ja
      integer i,j
      real    a(na,na)
      real    c

      do i=1,na
        a(i,ja) = c
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine mat_setrow(a,na,ia,c)
      include 'SIZE'
c     set row ia of matrix a to c
      integer na, ia
      integer i,j
      real    a(na,na)
      real    c

      do j=1,na
        a(ia,j) = c
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine gen_iden(a,ia)
      include 'SIZE'
c     construct identity matrix a(ia,ia)
      real    a(ia,ia)
      integer i,j

      call rzero(a,ia*ia)
      do i=1,ia
        a(i,i) = 1.
      enddo
c     write(6,*) 'a id',(a(j,1),j=1,ia*ia)

      return
      end
c-----------------------------------------------------------------------
      subroutine gen_gfac_3d(g)
      include 'SIZE'
c     construct g factors
      real    g(6,lx1*ly1*lz1,1)


      return
      end
c-----------------------------------------------------------------------
      subroutine gen_gfac_2d(g)
      include 'SIZE'
      include 'GEOM'
c     construct g factors
      real    g(3,lx1*ly1, 1)

      ! for now, just copy
      do ie=1,nelt
      do i=1,nx1*ny1
        g(1,i,ie) = g1m1(i,1,1,ie) ! rr, has mass, Jacobian
        g(2,i,ie) = g2m1(i,1,1,ie) ! ss
        g(3,i,ie) = g4m1(i,1,1,ie) ! rs
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine gen_gfac(g)
      include 'SIZE'
c     construct g factors
      real    g(1)

      if(ldim.eq.2) call gen_gfac_2d(g)
      if(ldim.eq.3) call gen_gfac_3d(g)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_build_lbe_2d(lbe,lbx,rbx,lby,rby
     $           ,llx,lmx,lrx,lly,lmy,lry,h1
     $           ,ux,uy,ie)
      include 'SIZE'
      include 'GEOM' ! rxm1, jacm1
      include 'WZ'   ! w3m1
      include 'DXYZ' ! dxm1

      integer lbx,rbx,lby,rby
      real    llx,lmx,lrx,lly,lmy,lry
      real    lbe(lx1,lx1,lx1,lx1) ! build array

      real    dr(lx1,lx1,lx1,lx1)  , drt(lx1,lx1,lx1,lx1)
     $      , ds(lx1,lx1,lx1,lx1)  , dst(lx1,lx1,lx1,lx1)
     $      , tmpr(lx1,lx1,lx1,lx1), tmps(lx1,lx1,lx1,lx1)    
     $      , wrk(lx1,lx1,lx1,lx1) , dif(lx1,lx1,lx1,lx1)
      real    di(lx1,lx1)

      real    gfc(ldim*(ldim+1)/2, lx1*ly1*lz1,lelt) ! ALL the G factors
      common /adfmgfc/ gfc

      integer i,j,k,l

c     common /adfsch/ as_ah, as_bh, as_ch, as_dh, as_dht, as_zh
c     real    as_ah(lx1,lx1), as_bh(lx1)
c    $      , as_ch(lx1,lx1), as_dh(lx1,lx1), as_dht(lx1,lx1)
c    $      , as_zh(lx1)

      integer icald
      data    icald / 0 /
      save    icald

      ! coefficients
      real    h1(lx1,ly1) ! starting from the element count
      real    ux(lx1,ly1), uy(lx1,ly1)
      real    mas

      n    = lx1
      nxyz = nx1*ny1*nz1
      nl   = lx1*lx1

      call gen_iden(di,n)
      call kron2(dr,di,n,n,as_dh,n,n) ! Dr
      call kron2(ds,as_dh,n,n,di,n,n) ! Ds

      if(icald.eq.0) then
        call gen_gfac(gfc) ! all eht elems, only once
        icald = 1
      endif

      call rzero(lbe,n*n*n*n)
      do l=1,n
      do k=1,n
      do j=1,n
      do i=1,n

        hv = h1(i,j)
        ij = i + (j-1)*n
        g1 = gfc(1,ij,ie)
        g2 = gfc(2,ij,ie)
        g3 = gfc(3,ij,ie)
        tmpr(i,j,k,l) = hv* (g1*dr(i,j,k,l) + g3*ds(i,j,k,l))
        tmps(i,j,k,l) = hv* (g3*dr(i,j,k,l) + g2*ds(i,j,k,l))
      enddo
      enddo
      enddo
      enddo

      call transpose(drt,nl,dr,nl)
      call transpose(dst,nl,ds,nl)
      call mxm(drt,nl,tmpr,nl,dif,nl) ! nl x nl
      call mxm(dst,nl,tmps,nl,wrk,nl) !
      call add2(dif, wrk, nl*nl)      ! save diffusion op
      call copy(lbe,dif,nl*nl)        ! add to lbe

      ! keep the advection as is for now
      do l=1,n
      do k=1,n
      do j=1,n
      do i=1,n
        u1 = ux(i,j)
        u2 = uy(i,j)
        cr = (u1*rxm1(i,j,1,ie) + u2*rym1(i,j,1,ie))
        cs = (u1*sxm1(i,j,1,ie) + u2*sym1(i,j,1,ie))
        mas = w3m1(i,j,1)

        lbe(i,j,k,l) = lbe(i,j,k,l)
     $   + cr * mas * dr(i,j,k,l)
     $   + cs * mas * ds(i,j,k,l)
c       if(ie.eq.1.or.ie.eq.3) then
c         write(6,*) ie,i,j,k,l,cr,cs,mas,'inside build'
c       endif
      enddo
      enddo
      enddo
      enddo

c     if(ie.eq.6) write(6,*) 'l  a', (lbe(i,1,1,1),i=1,n*n*n*n)
      ! figure out boundary conditions
      call lbe_bdry_2d(lbe,lbx,rbx,lby,rby
     $                ,ux,uy,gfc,dr,ds,drt,dst,h1,dif,n,ie)
c     if(ie.eq.6) write(6,*) 'l  b', (lbe(i,1,1,1),i=1,n*n*n*n)
c     if(ie.eq.6) call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine lbe_bdry_2d(lbe,lbr,rbr,lbs,rbs
     $                      ,ux,uy,gfc,dr,ds,drt,dst,h1,dif,n,ie)
      ! only works for box geometry, because summing
      !  tail to head means repeating the element corners
      include 'SIZE'
      real    lbe(n,n,n,n)
      real    tmp(n*n,n*n)
      real    ux(1), uy(1), gfc(1), dr(1), ds(1), dif(1)
     $      , drt(1), dst(1), h1(1)
      integer lbr, rbr, lbs, rbs
      integer n, ie
      integer icase(8)
      common  /adfmmsk/ rmsk
      real              rmsk(lx1**ldim,lelt) ! assume setup

      nl = n * n
      zr = 0.

      ! this should work
      call lbe_bdry_2d_asmb(lbe,lbr,rbr,lbs,rbs
     $                      ,ux,uy,gfc,dr,ds,drt,dst,h1,dif,n,ie)

      return
      end
c-----------------------------------------------------------------------
      subroutine lbe_bdry_2d_asmb(lbe,lbr,rbr,lbs,rbs
     $                      ,ux,uy,gfc,dr,ds,drt,dst,h1,dif,n,ie)
      ! assemble
      include 'SIZE'
      include 'GEOM'
      include 'WZ'
      real    lbe(n,n,n,n)
      real    tmp(n*n,n*n)
      real    ux(n,n), uy(n,n), h1(n,n), gfc(3,n*n,1)
      real    dr(n,n,n,n), ds(n,n,n,n)
     $      , drt(n,n,n,n), dst(n,n,n,n)
     $      , dif(n,n,n,n)
      integer lbr, rbr, lbs, rbs
      integer n, ie
      integer icase(8)
      common  /adfmmsk/ rmsk
      real              rmsk(lx1**ldim,lelt) ! assume setup
      real    mas
      real    tmpr(n*n), tmps(n*n)

      ! in 3D this will be a nightmare
      call izero(icase,8) ! 8 cases, 4 sides, 4 points
      if(lbr.eq.0) icase(1) = 1
      if(rbr.eq.0) icase(2) = 1
      if(lbs.eq.0) icase(3) = 1
      if(rbs.eq.0) icase(4) = 1
      icase(5) = icase(1)*icase(3) ! 1 when both sides are 1
      icase(6) = icase(1)*icase(4) ! 1 when both sides are 1
      icase(7) = icase(2)*icase(3) ! 1 when both sides are 1
      icase(8) = icase(2)*icase(4) ! 1 when both sides are 1
c     write(6,*) 'ie',ie
c     write(6,*) 'case',(icase(i),i=1,8)

      nl = n*n
      zr = 0.
      call rzero(tmp,nl*nl)

      do ni=1,4
        if(icase(ni).eq.1) then ! need assemble
          if(ni.eq.1) then
            istart = 1
            jstart = 1
            iskip  = n
            jskip  = n
            idsrc  = n - 1
            jdsrc  = n - 1
          elseif(ni.eq.2) then
            istart = n
            jstart = n
            iskip  = n
            jskip  = n
            idsrc  = - n + 1
            jdsrc  = - n + 1
          elseif(ni.eq.3) then
            istart = 1
            jstart = 1
            iskip  = 1
            jskip  = 1
            idsrc  =   nl - n
            jdsrc  =   nl - n
          elseif(ni.eq.4) then
            istart = nl-n+1
            jstart = nl-n+1
            iskip  = 1
            jskip  = 1
            idsrc  = - nl + n
            jdsrc  = - nl + n
          endif
          do jj=1,n
          do ii=1,n
            i = istart + (ii-1)*iskip
            j = jstart + (jj-1)*jskip
            isrc = i + idsrc
            jsrc = j + jdsrc
            u1 = ux(i,1)
            u2 = uy(i,1)
            mas = w3m1(i,1,1)
            cr = u1*rxm1(i,1,1,ie)+u2*rym1(i,1,1,ie)
            cs = u1*sxm1(i,1,1,ie)+u2*sym1(i,1,1,ie)
            tmp(i,j) = tmp(i,j) + cr*mas*dr(isrc,1,jsrc,1)
     $                          + cs*mas*ds(isrc,1,jsrc,1)
            do k=1,nl
              tmpr(k) = ( gfc(1,k,ie)*dr(k,1,jsrc,1)
     $                +   gfc(3,k,ie)*ds(k,1,jsrc,1) ) * h1(i,1)
              tmps(k) = ( gfc(3,k,ie)*dr(k,1,jsrc,1)
     $                +   gfc(2,k,ie)*ds(k,1,jsrc,1) ) * h1(i,1)
            enddo
            vdr = vlsc2(dr(1,1,isrc,1),tmpr,nl)
            vds = vlsc2(ds(1,1,isrc,1),tmps,nl)
            tmp(i,j) = tmp(i,j) + (vdr + vds)
c           if(ie.eq.6) then
c             write(6,*) i,j,isrc,jsrc,ni,mas,cr,cs,lbe(isrc,1,jsrc,1)
c    $                  ,'check asmb'
c           endif
          enddo
          enddo
        endif
      enddo

      do ni=5,8
      if(icase(ni).eq.1) then !
        if(ni.eq.5) then
          i = 1
        elseif(ni.eq.6) then
          i = nl - n + 1
        elseif(ni.eq.7) then
          i = n
        elseif(ni.eq.8) then
          i = nl
        endif
        isrc = nl - i + 1
        u1 = ux(i,1)
        u2 = uy(i,1)
        mas = w3m1(i,1,1)
        cr = u1*rxm1(i,1,1,ie)+u2*rym1(i,1,1,ie)
        cs = u1*sxm1(i,1,1,ie)+u2*sym1(i,1,1,ie)
        tmp(i,i) = tmp(i,i) + cr*mas*dr(isrc,1,isrc,1)
     $                      + cs*mas*ds(isrc,1,isrc,1)
        do k=1,nl
          tmpr(k) = ( gfc(1,k,ie)*dr(k,1,isrc,1)
     $            +   gfc(3,k,ie)*ds(k,1,isrc,1) ) * h1(i,1)
          tmps(k) = ( gfc(3,k,ie)*dr(k,1,isrc,1)
     $            +   gfc(2,k,ie)*ds(k,1,isrc,1) ) * h1(i,1)
        enddo
        vdr = vlsc2(dr(1,1,isrc,1),tmpr,nl)
        vds = vlsc2(ds(1,1,isrc,1),tmps,nl)
        tmp(i,i) = tmp(i,i) + (vdr + vds)
      endif
      enddo

      call add2(lbe,tmp,nl*nl) ! big

      do j=1,n
      do i=1,n
        ij = i + (j-1)*n
        if(rmsk(ij,ie).lt.0.5) then
c         write(6,*) ij,ie,'flagged to be bdry'
          call mat_setrow(lbe,nl,ij,zr) ! the ij-th row
          call mat_setcol(lbe,nl,ij,zr) ! the ij-th col
          lbe(ij,1,ij,1) = 1.           ! diag term
        endif
      enddo
      enddo
c     write(6,*) lx1,lbr,rbr,lbs,rbs,'what'

      return
      end
c-----------------------------------------------------------------------
c----------------------------------------------------------------------
      subroutine adfmn_setup_schwz_wt(ifsqrt)
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'

      integer l,i,nl,nlz
      logical ifsqrt

      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)

      call adfmn_setup_schwz_wt_1(oswt,ifsqrt)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_schwz_wt_1(wt,ifsqrt)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'TSTEP'  ! ifield
      include 'HSMGL'

      parameter(ls=lx1+2)
      real    wt(1)
      logical ifsqrt
      ! replace mg_work by tmp1, mg_work(i) by tmp2
      real tmp1(ls*ls*ls*lelt) ! not always on S grid
     $   , tmp2(ls*ls*ls*lelt) ! always on S grid

      integer enx,eny,enz !,pm

      ! no extrusion needed
      zero =  0
      one  =  1
      onem = -1

      enx=lx1
      eny=ly1
      enz=lz1
      if(.not.if3d) enz=1
      ns = enx*eny*enz*nelfld(ifield) ! oversized
      i  = ns+1

      call rone     (tmp1,ns)
      call adf_dssum(tmp1)

      nx = lx1
      ny = ly1
      nz = lz1
      if (.not.if3d) nz=1
      nxyz = nx*ny*nz
      k    = 1
      do ie=1,nelfld(ifield)
c        call outmat(mg_work(k),nx,ny,'NEW WT',ie)
         call adfmn_setup_schwz_wt_2(wt,ie,nx,tmp1(k),ifsqrt)
         k = k+nxyz
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmn_setup_schwz_wt_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      real wt(1),work(1)
      logical ifsqrt

      if(ldim.eq.2) call adfmn_setup_schwz_wt2d_2(wt,ie,n,work,ifsqrt)
      if(ldim.eq.3) call adfmn_setup_schwz_wt3d_2(wt,ie,n,work,ifsqrt)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_schwz_wt2d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,4,2,nelt)
      real work(n,n)
      
      integer ie,i,j
      do j=1,n
         wt(j,1,1,ie)=1.0/work(1,j)
         wt(j,2,1,ie)=1.0/work(2,j)
         wt(j,3,1,ie)=1.0/work(n-1,j)
         wt(j,4,1,ie)=1.0/work(n,j)
      enddo
      do i=1,n
         wt(i,1,2,ie)=1.0/work(i,1)
         wt(i,2,2,ie)=1.0/work(i,2)
         wt(i,3,2,ie)=1.0/work(i,n-1)
         wt(i,4,2,ie)=1.0/work(i,n)
      enddo
      if(ifsqrt) then
         do ii=1,2
         do j=1,4
         do i=1,n
            wt(i,j,ii,ie)=sqrt(wt(i,j,ii,ie))
         enddo
         enddo
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmn_setup_schwz_wt3d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,n,4,3,nelt) ! 4x3 is the same as 6x2
      real work(n,n,n)
      
      integer ie,i,j,k
      integer lbr,rbr,lbs,rbs,lbt,rbt

      ierr = 0
      do k=1,n
      do j=1,n
         wt(j,k,1,1,ie)=1.0/work(1,j,k)
         wt(j,k,2,1,ie)=1.0/work(2,j,k)
         wt(j,k,3,1,ie)=1.0/work(n-1,j,k)
         wt(j,k,4,1,ie)=1.0/work(n,j,k)
      enddo
      enddo
      do k=1,n
      do i=1,n
         wt(i,k,1,2,ie)=1.0/work(i,1,k)
         wt(i,k,2,2,ie)=1.0/work(i,2,k)
         wt(i,k,3,2,ie)=1.0/work(i,n-1,k)
         wt(i,k,4,2,ie)=1.0/work(i,n,k)
      enddo
      enddo
      do j=1,n
      do i=1,n
         wt(i,j,1,3,ie)=1.0/work(i,j,1)
         wt(i,j,2,3,ie)=1.0/work(i,j,2)
         wt(i,j,3,3,ie)=1.0/work(i,j,n-1)
         wt(i,j,4,3,ie)=1.0/work(i,j,n)
      enddo
      enddo
      if(ifsqrt) then
         do ii=1,3
         do k=1,4
         do j=1,4
         do i=1,n
            wt(i,j,k,ii,ie)=sqrt(wt(i,j,k,ii,ie))
         enddo
         enddo
         enddo
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfabarx(ax,xx,h1)
c
c     apply local version, advection diffusion operator, ax = A xx
c      not assembled!
c
      include 'SIZE'
      include 'TOTAL'
      parameter(lt=lx1*ly1*lz1*lelt)
      real     ax(1), xx(1), h1(1)
      common   /adftmp/ h2, tmp
      real     h2(lt), tmp(lt)

      nt = nx1*ny1*nz1*nelt

      call convop(ax,xx) ! adv, physical space
      call col2  (ax,bm1,nt)

c     call rzero (ax,nt) ! turn on so that only do Laplacian

      imesh = 1      ! is this right?
      isd = 1
      call rzero (h2,nt)
      call axhelm(tmp,xx,h1,h2,imesh,isd)
      call add2  (ax,tmp,nt)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfax(ax,xx,h1) ! only on mesh 1
c
c     apply advection diffusion operator, ax = A xx
c
      include 'SIZE'
      include 'TOTAL'
      parameter(lt=lx1*ly1*lz1*lelt)
      real     ax(lt), xx(lt), h1(lt)
      common   /adftmp/ h2, tmp
      real     h2(lt), tmp(lt)

      COMMON /FASTMD/ IFDFRM(LELT), IFFAST(LELT), IFH2, IFSOLV
      LOGICAL IFDFRM, IFFAST, IFH2, IFSOLV, ifuf, ifcf

      integer icald
      data    icald / 0 /
      save    icald

      nt = nx1*ny1*nz1*nelt

      ! not dealiased
c     call convop(ax,xx) ! adv, physical space
c     call col2  (ax,bm1,nt)

      !
      if (icald.eq.0) then
        call set_convect_new(vxd,vyd,vzd,vx,vy,vz)
        icald = 1
      endif
      ifuf = .false.
      ifcf = .true.
      call convect_new(ax,xx,ifuf,vxd,vyd,vzd,ifcf)

c     call rzero (ax,nt) ! turn on so that only do Laplacian

c     do ie=1,nelt
c       write(6,*) ie,ifdfrm(ie), iffast(ie),'logic ie,'
c     enddo

      imesh = 2      ! is this right?
      isd = 1
      call rzero (h2,nt)
      call axhelm(tmp,xx,h1,h2,imesh,isd)
      call add2  (ax,tmp,nt)
      call dssum (ax,lx1,ly1,lz1)
      call col2  (ax,tmask(1,1,1,1,1),nt)

      return
      end
c-----------------------------------------------------------------------
c---- Util functions
c-----------------------------------------------------------------------
      function ranx(idum)
c
      integer idum,ia,im,iq,ir,ntab,ndiv
      real    ranx,am,eps,rnmx
c
      parameter (ia=16807,im=2147483647,am=1./im,iq=127773,ir=2836)
      parameter (ntab=32,ndiv=1+(im-1)/ntab,eps=1.2e-7,rnmx=1.-eps)
c
c     Numerical Rec. in Fortran, 2nd eD.  P. 271
c
      integer j,k
      integer iv(ntab),iy
      save    iv,iy
      data    iv,iy /ntab*0,0/
c
      if (idum.le.0.or.iy.eq.0) then
         idum=max(-idum,1)
         do j=ntab+8,1,-1
            k    = idum/iq
            idum = ia*(idum-k*iq)-ir*k
            if(idum.lt.0) idum = idum+im
            if (j.le.ntab) iv(j) = idum
         enddo
         iy = iv(1)
      endif
      k    = idum/iq
      idum = ia*(idum-k*iq)-ir*k
      if(idum.lt.0) idum = idum+im
      j     = 1+iy/ndiv
      iy    = iv(j)
      iv(j) = idum
      ranx  = min(am*iy,rnmx)
c
      return
      end
c-----------------------------------------------------------------------
      subroutine adf_proj(x,res,h1,iter,maxit,wt)

c     Solve A t = r, via custome projection scheme

      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'
      parameter (lt=lx1*ly1*lz1*lelt)
      real res(1), x(1)
      real h1(1)
      integer iter, maxit, itall

      real r(lt),w(lt),d(lt),v(lt),z(lt)
     $   , wt(lt) ! multiplicity
      common /dadfpj/ d       ! Preconditioner
      common /cadfpj/ r,w     ! WORK ARRAYS
      common /zadfp1/ v
      common /zadfp2/ z
      common /zadfps/ p,q
      real            p(lt,lgmres), q(lt,lgmres)

      real   x0(lt), er(lt)

      real    proj_tol
      real    alpha, beta

      common /adfexc/ uex
      real            uex(lt)

      logical iflu

      ngo = -99        ! TURN OFF VERBOSE OUTPUT
      n = nx1*ny1*nz1*nelt
      proj_tol = 1.e-10 ! staganates at 5e-9
c     proj_tol = 1.e-12 ! staganates at 5e-9

      if (istep.le.20.or.mod(istep,10).eq.0) ngo = nio

      iflu = .true.
      if(param(104) .gt. 0.5) iflu = .false. ! use Tensor
      if(ldim.eq.3) iflu = .false.
      if(nio.eq.0) write(6,*) 'adfpj: if using LU:',iflu

      m     = lgmres
      mxs = 1 ! maximum schwarz iter - once?
      mxmg = 500 ! max MG
      iconv  = 0 ! if converged
      sigma = 0.5

      ! initial guess
      call rzero(x,n)                     ! Solution
      call rzero(x0,n)           ! all 0 initial guess

      iter = 1
      itall = 0
      do while (iter.lt.maxit)             ! Main proj loop
         if(iter.eq.1) then                ! first step :: r = res - A 0
            call copy   (r,res,n)
         else                              ! second up  :: r = res - A x
            call adfax  (w,x,h1)           ! w = A x
            call sub3   (r,res,w,n)        ! r = r - w
         endif

         ! preconditioner solve
                                           !       -1
c        call copy  (z,r,n)                ! z  = M  r

         img = 0
         mxmg = 1
         if (param(51).eq.0) then
            call col3(z,bintm1,r,n)
c          call copy(z,r,n)
         else if (iflu) then ! Li MG, only 2D
           call adfmn_mg_schwz(z,r,img,mxmg,wt)
         else !! Pablo MG, 2+3D
           call adfmn_mg_schwz_tens(z,r,img,mxmg,wt)
         endif
         itall = itall + img

         call adfax    (w,z,h1)            !w = A z
         do j=1,(iter-1)
           beta = glsc2(q(1,j),w,n)
           call add2s2(z,p(1,j),-beta,n)
           call add2s2(w,q(1,j),-beta,n)
         enddo
         beta = sqrt(glsc2(w,w,n))
         if(beta.lt.proj_tol) goto 900
         betai = 1./beta
         call copy (p(1,iter),z,n)
         call cmult(p(1,iter),betai,n)
         call copy (q(1,iter),w,n)
         call cmult(q(1,iter),betai,n)

         alpha = glsc2(q(1,iter),r,n)
         call add2s2(x,p(1,iter),alpha,n)

         if (ngo.eq.0) write(6,9)
     $         n,iter,beta,alpha,proj_tol,dt
    9    format(i9,i5,1p4e12.4,' tproj')
         istep = iter
         time  = real(iter)
         iter = iter + 1
         tmin = glmin(x,n)
         tmax = glmax(x,n)
         if (nio.eq.0) write (6,*) 'iter,tmin,tmax:',iter,tmin,tmax
         if(mod(iter,max(iostep,1)).eq.0) then
c          call sub3(er,x,uex,n)
c          call col2(er,tmask,n)
           call outpost(vx,vy,vz,pr,x,'   ')
c          call exitt
         endif

      enddo
  900 continue
      maxit = iter
      if (nio.eq.0) write(6,8)
     $   n,maxit,itall,beta,proj_tol,dt
    8    format(i9,i5,i8,1p3e12.4,' tprojb')

      istep = iter
      time  = real(iter)
      return
      end
c-----------------------------------------------------------------------
      subroutine adf_gmres(x,res,h1,iter,maxit,wt)

c     Solve A t = r, via gmres

      include 'SIZE'
      include 'TOTAL'
      parameter (lt=lx1*ly1*lz1*lelt)
      real res(1), x(1)
      real h1(1)
      integer iter, maxit

      real x0(lt)

      real r(lt),w(lt),d(lt),v(lt,lgmres),z(lt,lgmres)
     $   , wt(lt) ! multiplicity
      common /dgmres/ d       ! Preconditioner
      common /cgmres/ r,w     ! WORK ARRAYS
      common /egmre1/ v
      common /egmre2/ z

      real    gmtol_in
      real    alpha, l, temp
      common /gctmp/  h(lgmres,lgmres), gamma(lgmres+1)
     $              , c(lgmres), s(lgmres), wk1(lgmres)

      integer icalld
      save    icalld
      data    icalld / 0 / ! only do this once

      ngo = -99        ! TURN OFF VERBOSE OUTPUT
      nt = nx1*ny1*nz1*nelt
      gmtol_in = 1.e-12 !

      if (istep.le.20.or.mod(istep,10).eq.0) ngo = nio

      if (icalld.lt.0) call rone(d,nt)
      if (icalld.eq.0) then ! formulate preconditioner once
         call rone (d, nt)
      endif
      icalld=icalld+1

      m     = lgmres
      mxs = 1 ! maximum schwarz iter - once?
      iconv  = 0 ! if converged
      call rzero(x,nt)                     ! Solution
      call rzero(x0,nt)                     ! Solution

      do while (iconv.eq.0.and.iter.lt.maxit)    ! Main GMRES loop
         if(iter.eq.0) then                      ! first step :: r = res - A 0
            call copy   (r,res,nt)
         else                                     ! second up  :: r = res - A x
            call adfax  (w,x,h1)                  ! w = A x
            call sub3   (r,res,w,nt)              ! r = r - w
         endif
                                                  !            ______
c        gamma(1) = sqrt(glsc2(r,r,nt))           ! gamma  = \/ (r,r)
         gamma(1) = sqrt(glsc3(r,r,wt,nt))        ! gamma  = \/ (r,r)

         if (gamma(1).eq.0.) goto 9000            ! check for lucky convergence

         temp = 1./gamma(1)
         call cmult2(v(1,1),r,temp,nt)            ! v  = r / gamma
                                                  !  1            1
         do j=1,m ! Krylov space
            iter = iter+1
                                                  !       -1
            call col3  (z(1,j),d,v(1,j),nt)       ! z  = M  v
                                                  !  j       j
            isw = 0
c           call adf_schwz(z(1,j),x0,v(1,j),h1,isw,mxs,wt) ! works

            call adfax(w,z(1,j),h1              ) !w = A z
                                                  !       j
            do i=1,j                              ! Gram-Schmidt
c              h(i,j)=vlsc2(w,v(1,i),nt)          ! h    = (w,v )
               h(i,j)=vlsc3(w,v(1,i),wt,nt)       ! h    = (w,v )
            enddo                                 !  i,j       i
            call gop(h(1,j),wk1,'+  ',j)          ! sum over P procs
            do i=1,j
               call add2s2(w,v(1,i),-h(i,j),nt)   ! w = w - h    v
            enddo                                 !          i,j  i

            !apply Givens rotations to new column
            do i=1,j-1
               temp = h(i,j)
               h(i  ,j)=  c(i)*temp + s(i)*h(i+1,j)
               h(i+1,j)= -s(i)*temp + c(i)*h(i+1,j)
            enddo
                                                  !            ______
c           alpha = sqrt(glsc2(w,w,nt))           ! alpha =  \/ (w,w)
            alpha = sqrt(glsc3(w,w,wt,nt))        ! alpha =  \/ (w,w)

            if (alpha.eq.0.) goto 900             ! converged

            l = sqrt(h(j,j)*h(j,j)+alpha*alpha)
            temp = 1./l
            c(j) = h(j,j) * temp
            s(j) = alpha  * temp
            h(j,j) = l

            gamma(j+1) = -s(j) * gamma(j)
            gamma(j)   =  c(j) * gamma(j)
            rnorm = abs(gamma(j+1))

            if (rnorm .lt. gmtol_in) goto 900     !converged
            ! if (alpha .lt. gmtol_in) goto 900     !converged

            if (j.eq.m) goto 1000                 ! not converged, restart

            temp = 1./alpha
            call cmult2(v(1,j+1),w,temp,nt)       ! v    = w / alpha

            if (ngo.eq.0) write(6,9)
     $         istep,iter,j,rnorm,gmtol_in,dt
    9       format(i9,2i5,1p3e12.4,' tgmrs')
         enddo
  900    iconv = 1
 1000    continue

         !back substitution
         !     -1
         !c = H   gamma
         do k=j,1,-1
            temp = gamma(k)
            do i=j,k+1,-1
               temp = temp - h(k,i)*c(i)
            enddo
            c(k) = temp/h(k,k)
         enddo
         !sum up Arnoldi vectors
         do i=1,j
            call add2s2(x,z(1,i),c(i),nt)  ! x = x + c  z
                                           !          i  i
         enddo
      enddo
 9000 continue
      maxit = iter
      if (nio.eq.0) write(6,8)
     $   istep,maxit,j,rnorm,gmtol_in,dt
    8    format(i9,2i5,1p3e12.4,' tgmrsb')

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_setup_wtmask ! h1mg_setup_wtmask
      include 'SIZE'
      include 'HSMGL'
      integer i,l
      i = mg_mask_index(mg_lmax,mg_fld-1)
      do l=1,mg_lmax
         mg_rstr_wt_index(l,mg_fld)=i
         mg_mask_index   (l,mg_fld)=i
         i=i+mg_nh(l)*mg_nhz(l)*2*ldim*nelt
         if(i .gt. lmgs*lmg_rwt*2*ldim*lelt) then
            itmp = i/(2*ldim*lelv)
            write(6,*) 'parameter lmg_rwt too small',i,itmp,lmg_rwt
            call exitt
         endif
         call adfmg_setup_rstr_wt(
     $           mg_rstr_wt(mg_rstr_wt_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
         call adfmg_setup_mask_hs(
     $           mg_mask(mg_mask_index(l,mg_fld))
     $          ,mg_nh(l),mg_nh(l),mg_nhz(l),l,mg_work)
      enddo
      mg_mask_index(l,mg_fld)=i
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_rstr_wt(wt,nx,ny,nz,l,w)
      include 'SIZE'
      include 'INPUT'
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)
      
      integer ie
      !init border nodes to 1
      call rzero(w,nx*ny*nz*nelt)
c     print *, 'Setup rstr wt: ',nx,ny,nz,nelt
      if (.not.if3d) then
         do ie=1,nelt
            do i=1,nx
               w(i,1,1,ie)=1.0
               w(i,ny,1,ie)=1.0
            enddo
            do j=1,ny
               w(1,j,1,ie)=1.0
               w(nx,j,1,ie)=1.0
            enddo
         enddo
      else
         do ie=1,nelt
            do j=1,ny
            do i=1,nx
               w(i,j,1,ie)=1.0
               w(i,j,nz,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=1.0
               w(i,ny,k,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=1.0
               w(nx,j,k,ie)=1.0
            enddo
            enddo
         enddo
      endif
      call adfmg_dssum(w,l)
      !invert the count w to get the weight wt
      if (.not. if3d) then
         do ie=1,nelt
            do j=1,ny
               wt(j,1,1,1,ie)=1.0/w(1,j,1,ie)
               wt(j,1,2,1,ie)=1.0/w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=1.0/w(i,1,1,ie)
               wt(i,1,2,2,ie)=1.0/w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=1.0/w(1,j,k,ie)
               wt(j,k,2,1,ie)=1.0/w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=1.0/w(i,1,k,ie)
               wt(i,k,2,2,ie)=1.0/w(i,ny,k,ie)
            enddo
            enddo
            do j=1,ny
            do i=1,nx
               wt(i,j,1,3,ie)=1.0/w(i,j,1,ie)
               wt(i,j,2,3,ie)=1.0/w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_mask_hs(wt,nx,ny,nz,l,w) ! hs version
      include 'SIZE'
      include 'INPUT'
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)
      
      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two
c     init everything to 1

      n = nx*ny*nz*nelt
      call rone(w,n)

c     set dirichlet nodes to zero
      ierr = 0
      two  = 2
      do ie=1,nelt
         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
         if (ierr.ne.0) then
            ierr = -1
            call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
         endif

         if(lbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(nx,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(lbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,ny,k,ie)=0.0
            enddo
            enddo
         endif
         if(if3d) then
            if(lbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,1,ie)=0.0
               enddo
               enddo
            endif
            if(rbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,nz,ie)=0.0
               enddo
               enddo
            endif
         endif
      enddo
c     do direct stiffness multiply
      call adfmg_dsprod(w,l)

c     store weight
      if (.not. if3d) then
         do ie=1,nelt
            do j=1,ny
               wt(j,1,1,1,ie)=w(1,j,1,ie)
               wt(j,1,2,1,ie)=w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=w(i,1,1,ie)
               wt(i,1,2,2,ie)=w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=w(1,j,k,ie)
               wt(j,k,2,1,ie)=w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=w(i,1,k,ie)
               wt(i,k,2,2,ie)=w(i,ny,k,ie)
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               wt(j,k,1,3,ie)=w(i,j,1,ie)
               wt(j,k,2,3,ie)=w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif

      ierrmx = iglmax(ierr,1)
      if (ierrmx.gt.0) then
         if ((ierr.gt.0).and.(nio.eq.0)) write(6,*) nid,ierr,' BC FAIL'
         call exitti('B INVALID BC FOUND in genfast$',ierrmx)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_index_0 ! initialize index sets
      include 'SIZE'
      include 'HSMGL'

      n = lmgn*(lmgs+1)

      call izero( mg_rstr_wt_index      , n )
      call izero( mg_mask_index         , n )
      call izero( mg_solve_index        , n )
      call izero( mg_fast_s_index       , n )
      call izero( mg_fast_d_index       , n )
      call izero( mg_schwarz_wt_index   , n )
      
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_solve
      include 'SIZE'
      include 'HSMGL'
      
      integer l,i,nl,nlz
      i = mg_solve_index(mg_lmax+1,mg_fld-1)
      do l=1,mg_lmax
         mg_solve_index(l,mg_fld)=i
         i=i+mg_nh(l)*mg_nh(l)*mg_nhz(l)*nelt
         if(i .gt. lmg_solve*lelt) then
            itmp = i/lelv
            write(6,*) 'lmg_solve too small',i,itmp,lmg_solve,l
            call exitt
         endif
      enddo
      mg_solve_index(l,mg_fld)=i

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_dssum
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'HSMGL'
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)

      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l
      
      ncrnr = 2**ldim
      call get_vert

      do l=1,mg_lmax  ! set up direct stiffness summation for each level
         nx=mg_nh(l)
         ny=mg_nh(l)
         nz=mg_nhz(l)
         call setupds(mg_gsh_handle(l,mg_fld),nx,ny,nz
     $                ,nelt,nelgt,vertex,glo_num)
c        nx=nx+2
c        ny=ny+2
c        nz=nz+2
c        if(.not.if3d) nz=1
c        call setupds(mg_gsh_schwarz_handle(l,mg_fld),nx,ny,nz
c    $                ,nelt,nelgt,vertex,glo_num)
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_intp
      include 'SIZE'
      include 'HSMGL'
      include 'SEMHAT'
      integer l,nf,nc

      do l=1,mg_lmax-1

         nf=mg_nh(l+1)
         nc=mg_nh(l)

!        Standard multigrid coarse-to-fine interpolation
         call adfmg_setup_intpm(
     $           mg_jh(1,l),mg_zh(1,l+1),mg_zh(1,l),nf,nc)
         call transpose(mg_jht(1,l),nc,mg_jh(1,l),nf)

!        Fine-to-coarse interpolation for variable-coefficient operators
         call adfmg_setup_intpm(
     $           mg_jhfc(1,l),mg_zh(1,l),mg_zh(1,l+1),nc,nf)
         call transpose(mg_jhfct(1,l),nf,mg_jhfc(1,l),nc)
c        call outmat(mg_jhfc(1,l),nc,nf,'MG_JHFC',l)

      enddo
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_intpm(jh,zf,zc,nf,nc)
      integer nf,nc
      real jh(nf,nc),zf(1),zc(1)
      include 'SIZE'
      real w(2*lx1+2)
      do i=1,nf
         call fd_weights_full(zf(i),zc,nc-1,1,w)
         do j=1,nc
            jh(i,j)=w(j)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_semhat ! SEM hat matrices for each level
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      include 'SEMHAT'

      do l=1,mg_h1_lmax
         n = mg_nx(l)     ! polynomial order
         call semhat(ah,bh,ch,dh,zh,dph,jph,bgl,zglhat,dgl,jgl,n,wh)
         call copy(mg_ah(1,l),ah,(n+1)*(n+1))
         call copy(mg_bh(1,l),bh,n+1)
c        write(6,*) 'bh  ',(bh(i),i=1,n+1)
c        write(6,*) 'mgbh',(mg_bh(i,l),i=1,n+1)
         call copy(mg_dh(1,l),dh,(n+1)*(n+1))
         call transpose(mg_dht(1,l),n+1,dh,n+1)
         call copy(mg_zh(1,l),zh,n+1)
         mg_nh(l)=n+1
         mg_nhz(l)=mg_nz(l)+1
      enddo
      end
c-----------------------------------------------------------------------
      subroutine adfmg_set_co(p_c,l0) ! advection coefficients
      include 'SIZE'
      include 'HSMGL'
      include 'MASS'   ! bm1
      include 'TSTEP'  ! nelfld

      include 'PARALLEL' ! nid

      integer p_c,e, l0
      common /ctmp1/ w(lx1*ly1*lz1*lelt*2)

      common /adfco/  co
      real            co(lmg_g*ldim*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?

c     write(6,*) 'adfmg set co: ',mg_lmax
      l                 = mg_lmax
      pco    (l,mg_fld) = 1 ! NOT 0 ! ! ! !
      n                 = mg_h1_n(l,mg_fld)

      nc = ldim  ! 2 or 3 elements to adv cr,cs,ct tensor

      do l=mg_lmax-1,1,-1
         pco(l,mg_fld) = pco    (l+1,mg_fld) + n*nc
         n             = mg_h1_n(l  ,mg_fld)
      enddo

      do e=1,nelfld(mg_fld)
       do l=mg_lmax,1,-1

         nx = mg_nh(l)
         ny = mg_nh(l)
         nz = mg_nhz(l)
         nxyz = nx*ny*nz
         p_c = pco(l,mg_fld) + nc*nx*ny*nz*(e-1)

         if (l.eq.mg_lmax) then
           ! fine grid, evaluate cr=cx rx + cy ry + cz rz
           call co_e(co(p_c),nc,e)

           call adfmg_scale_mass_co     ! Divide out Wghts for intp
     $         (co(p_c),mg_bh(1,l),nc,nx,ny,nz,w,.true.)
         else
c           Generate G and B by interpolating their continous counterparts onto
c           the coarse grid and collocating with coarse-grid quadrature weights
            call mg_intp_cfc_e
     $            (co(p_c),co(l_c),nc,nx,ny,nz,nxl,nyl,nzl,e,l,w)
            call adfmg_scale_mass_co     ! Multiply by wghts
     $         (co(l_c),mg_bh(1,l+1),nc,nxl,nyl,nzl,w,.false.)
         endif
         l_c = p_c ! lag
         nxl = nx
         nyl = ny
         nzl = nz
       enddo
       call adfmg_scale_mass_co     ! Multiply by wghts
     $          (co(l_c),mg_bh(1,1),nc,nxl,nyl,nzl,w,.false.)
      enddo
      p_c  = pco(l0,mg_fld)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_set_gb  (p_g,p_b,l0)
      include 'SIZE'
      include 'HSMGL'
      include 'MASS'   ! bm1
      include 'TSTEP'  ! nelfld

      include 'PARALLEL'  ! nid

      integer p_g,p_b,e
      common /ctmp1/ w(lx1*ly1*lz1*lelt*2)

      l                 = mg_h1_lmax
      p_mg_b (l,mg_fld) = 0
      p_mg_g (l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)


      ng = 3*(ldim-1)  ! 3 or 6 elements to symm dxd tensor

      do l=mg_h1_lmax-1,1,-1
         p_mg_b (l,mg_fld) = p_mg_b (l+1,mg_fld) + n
         p_mg_g (l,mg_fld) = p_mg_g (l+1,mg_fld) + n*ng
         n                 = mg_h1_n(l  ,mg_fld)
      enddo

c     write(6,*) 'adfmg set gb :: ifld, nel',ifield,nelfld(ifield)
      do e=1,nelfld(ifield)
       do l=mg_h1_lmax,1,-1

         nx = mg_nh(l)
         ny = mg_nh(l)
         nz = mg_nhz(l)
         nxyz = nx*ny*nz
         p_g = p_mg_g (l,mg_fld) + ng*nx*ny*nz*(e-1)
         p_b = p_mg_b (l,mg_fld) +    nx*ny*nz*(e-1)
         if (l.eq.mg_h1_lmax) then
            call adf_gxfer_e(mg_g(p_g),ng,e)            ! Fine grid=original G
            call copy    (mg_b(p_b) ,bm1(1,1,1,e),nxyz) ! Fine grid=original B
            call adfmg_scale_mass                       ! Divide out Wghts
     $         (mg_b(p_b),mg_g(p_g),mg_bh(1,l),ng,nx,ny,nz,w,.true.)
         else
c        Generate G and B by interpolating their continous counterparts onto
c        the coarse grid and collocating with coarse-grid quadrature weights

            call adfmg_intp_gfc_e
     $            (mg_g(p_g),mg_g(l_g),ng,nx,ny,nz,nxl,nyl,nzl,e,l,w)

            call adfmg_intp_fc_e
     $            (mg_b(p_b),mg_b(l_b)   ,nx,ny,nz,nxl,nyl,nzl,e,l,w)

            call adfmg_scale_mass                         ! Reinstate weights
     $      (mg_b(l_b),mg_g(l_g),mg_bh(1,l+1),ng,nxl,nyl,nzl,w,.false.)

         endif

         l_b = p_b
         l_g = p_g

         nxl = nx
         nyl = ny
         nzl = nz

       enddo

       call adfmg_scale_mass                         ! Reinstate weights
     $      (mg_b(l_b),mg_g(l_g),mg_bh(1,1),ng,nxl,nyl,nzl,w,.false.)

      enddo

      p_b  = p_mg_b (l0,mg_fld)
      p_g  = p_mg_g (l0,mg_fld)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_intp_fc_e(uc,uf,nxc,nyc,nzc,nxf,nyf,nzf,e,l,w)
      include 'SIZE'
      include 'INPUT'      ! if3d
      include 'HSMGL'

      real uf(nxf,nyf,nzf),uc(nxc,nyc,nzc),w(1)

      if (if3d) then

         n1=nxf*nyf
         n2=nzf
         n3=nzc
         call mxm(uf,n1,mg_jhfct(1,l),n2,w,n3)

         lf=1           ! pointers into work array w()
         lc=1 + n1*n3
         lc0=lc

         n1=nxf
         n2=nyf
         n3=nyc

         do k=1,nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,w(lc),n3)
            lf = lf + n1*n2
            lc = lc + n1*n3
         enddo

         lf=lc0  ! Rewind fine pointer to start of coarse data
         n1=nxc
         n2=nxf
         n3=nyc*nzc
         call mxm(mg_jhfc(1,l),n1,w(lf),n2,uc,n3)

      else ! 2D

         n1=nxf
         n2=nyf
         n3=nyc
         call mxm(uf,n1,mg_jhfct(1,l),n2,w,n3)

         n1=nxc
         n2=nxf
         n3=nyc
         call mxm(mg_jhfc(1,l),n1,w,n2,uc,n3)

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_intp_gfc_e(gc,gf,ng,nxc,nyc,nzc,nxf,nyf,nzf
     $                           ,e,l,w)
      include 'SIZE'
      include 'INPUT'      ! if3d
      include 'HSMGL'

      real gf(ng,nxf,nyf,nzf),gc(ng,nxc,nyc,nzc),w(1)


      if (if3d) then

         n1=ng*nxf*nyf
         n2=nzf
         n3=nzc
         call mxm(gf,n1,mg_jhfct(1,l),n2,w,n3)

         lf=1           ! pointers into work array w()
         lc=1 + n1*n3
         lc0=lc

         n1=ng*nxf
         n2=nyf
         n3=nyc

         do k=1,nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,w(lc),n3)
            lf = lf + n1*n2
            lc = lc + n1*n3
         enddo

         lf=lc0  ! Rewind fine pointer to start of coarse data
         n1=ng
         n2=nxf
         n3=nxc

         do k=1,nyc*nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,gc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo

      else ! 2D

         n1=ng*nxf
         n2=nyf
         n3=nyc
         call mxm(gf,n1,mg_jhfct(1,l),n2,w,n3)

         lf=1           ! pointers into work array w()

         n1=ng
         n2=nxf
         n3=nxc

         do k=1,nyc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,gc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_scale_mass_co (co,wt,nc,nx,ny,nz,wk,ifinv)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'HSMGL'

      real    co(nc,1),wt(1),wk(1)
      logical ifinv

      common /ctmp0/ wi(2*lx1+4)

      n = nx*ny*nz

      if (nx.le.2*lx1) then
        if (ifinv) then ! divide weights from b, g
            call invers2(wi,wt,nx)
         else           ! multiply weights into b, g
            call copy(wi,wt,nx)
         endif
      else
         call exitti('adfmg_scale_mass_co: wi too small$',nx)
      endif

      if (ldim.eq.3) then
         l=0
         do k=1,nz
         do j=1,ny
            wjk=wi(j)*wi(k)
            do i=1,nx
               l=l+1
               wk(l) = wjk*wi(i)
            enddo
         enddo
         enddo

         do k=1,n
            co(1,k) = wk(k)*co(1,k)
            co(2,k) = wk(k)*co(2,k)
            co(3,k) = wk(k)*co(3,k)
         enddo

      else      ! 2D
         l=0
         do j=1,ny
         do i=1,nx
            l=l+1
            wk(l) = wi(i)*wi(j)
         enddo
         enddo

         do k=1,n
            co(1,k) = wk(k)*co(1,k)
            co(2,k) = wk(k)*co(2,k)
         enddo

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_scale_mass (b,g,wt,ng,nx,ny,nz,wk,ifinv)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'HSMGL'

      real b(1),g(ng,1),wt(1),wk(1)
      logical ifinv

      common /ctmp0/ wi(2*lx1+4)

      n = nx*ny*nz

      if (nx.le.2*lx1) then
        if (ifinv) then ! divide weights from b, g
            call invers2(wi,wt,nx)
         else           ! multiply weights into b, g
            call copy(wi,wt,nx)
         endif
      else
         call exitti('mg_scale_mass: wi too small$',nx)
      endif

      if (if3d) then
         l=0
         do k=1,nz
         do j=1,ny
            wjk=wi(j)*wi(k)
            do i=1,nx
               l=l+1
               wk(l) = wjk*wi(i)
            enddo
         enddo
         enddo

         do k=1,n
            b(k)   = wk(k)*b(k)
            g(1,k) = wk(k)*g(1,k)
            g(2,k) = wk(k)*g(2,k)
            g(3,k) = wk(k)*g(3,k)
            g(4,k) = wk(k)*g(4,k)
            g(5,k) = wk(k)*g(5,k)
            g(6,k) = wk(k)*g(6,k)
         enddo

      else      ! 2D
         l=0
         do j=1,ny
         do i=1,nx
            l=l+1
            wk(l) = wi(i)*wi(j)
         enddo
         enddo

         do k=1,n
            b(k)   = wk(k)*b(k)
            g(1,k) = wk(k)*g(1,k)
            g(2,k) = wk(k)*g(2,k)
            g(3,k) = wk(k)*g(3,k)
         enddo

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine mg_intp_cfc_e(cc,cf,nc,nxc,nyc,nzc,nxf,nyf,nzf,e,l,w)
      include 'SIZE'
      include 'INPUT'      ! if3d
      include 'HSMGL'

      real cf(nc,nxf,nyf,nzf),cc(nc,nxc,nyc,nzc),w(1)

      if (if3d) then

         n1=nc*nxf*nyf
         n2=nzf
         n3=nzc
         call mxm(cf,n1,mg_jhfct(1,l),n2,w,n3)

         lf=1           ! pointers into work array w()
         lc=1 + n1*n3
         lc0=lc

         n1=nc*nxf
         n2=nyf
         n3=nyc

         do k=1,nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,w(lc),n3)
            lf = lf + n1*n2
            lc = lc + n1*n3
         enddo

         lf=lc0  ! Rewind fine pointer to start of coarse data
         n1=nc
         n2=nxf
         n3=nxc

         do k=1,nyc*nzc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,cc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo

      else ! 2D

         n1=nc*nxf
         n2=nyf
         n3=nyc
         call mxm(cf,n1,mg_jhfct(1,l),n2,w,n3)

         lf=1           ! pointers into work array w()

         n1=nc
         n2=nxf
         n3=nxc

         do k=1,nyc
            call mxm(w(lf),n1,mg_jhfct(1,l),n2,cc(1,1,k,1),n3)
            lf = lf + n1*n2
         enddo

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine co_e (cf,nc,e)  ! mesh 1
      include 'SIZE'
      include 'TOTAL'

      real    cf(nc,1)
      integer e

      nxyz = lx1*ly1*lz1

      if(ldim.eq.3) then
         do i=1,nxyz
            ux = vx(i,1,1,e)
            uy = vy(i,1,1,e)
            uz = vz(i,1,1,e)
            cf(1,i) = w3m1(i,1,1)*
     $        (ux*rxm1(i,1,1,e) + uy*rym1(i,1,1,e) + uz*rzm1(i,1,1,e))
            cf(2,i) = w3m1(i,1,1)*
     $        (ux*sxm1(i,1,1,e) + uy*sym1(i,1,1,e) + uz*szm1(i,1,1,e))
            cf(3,i) = w3m1(i,1,1)*
     $        (ux*txm1(i,1,1,e) + uy*tym1(i,1,1,e) + uz*tzm1(i,1,1,e))
         enddo
       else
         do i=1,nxyz
            ux = vx(i,1,1,e)
            uy = vy(i,1,1,e)
            cf(1,i) = w3m1(i,1,1)*
     $        (ux*rxm1(i,1,1,e) + uy*rym1(i,1,1,e)                   )
            cf(2,i) = w3m1(i,1,1)*
     $        (ux*sxm1(i,1,1,e) + uy*sym1(i,1,1,e)                   )
         enddo
       endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_gxfer_e (g,ng,e) 
      include 'SIZE'
      include 'TOTAL'

      real g(ng,1)
      integer e

      nxyz = lx1*ly1*lz1

c     ifdfrm(e) = .true.  ! TOO LATE

      if (if3d) then
         do i=1,nxyz
            g(1,i) = g1m1(i,1,1,e)
            g(2,i) = g2m1(i,1,1,e)
            g(3,i) = g3m1(i,1,1,e)
            g(4,i) = g4m1(i,1,1,e)
            g(5,i) = g5m1(i,1,1,e)
            g(6,i) = g6m1(i,1,1,e)
         enddo
      else
         do i=1,nxyz
            g(1,i) = g1m1(i,1,1,e)
            g(2,i) = g2m1(i,1,1,e)
            g(3,i) = g4m1(i,1,1,e)
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_set_msk(p_msk ,l0) ! boundary mask
      include 'SIZE'
      include 'HSMGL'
      include 'TSTEP'
      integer p_msk

      l                  = mg_h1_lmax
      p_mg_msk(l,mg_fld) = 0
      n                  = mg_h1_n(l,mg_fld)


      do l=mg_h1_lmax,1,-1
         nx = mg_nh  (l)
         ny = mg_nh  (l)
         nz = mg_nhz (l)

         p_msk = p_mg_msk(l,mg_fld)

c        write(6,*) 'inside adfmg_set_msk:::'
         call adfmg_setup_mask ! h1mg_setup_mask
     $     (mg_imask(p_msk),nm,nx,ny,nz,nelfld(mg_fld),l,mg_work)

         if (l.gt.1) p_mg_msk(l-1,mg_fld)=p_mg_msk(l,mg_fld)+nm

c        write(6,*) p_msk,p_mg_msk(l-1,mg_fld),p_mg_msk(l,mg_fld),'M'

      enddo

      p_msk = p_mg_msk(l0,mg_fld)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_setup_mask(mask,nm,nx,ny,nz,nel,l,w) ! h1 version
      include 'SIZE'
      include 'INPUT'        ! if3d
      include 'TSTEP'        ! ifield

      integer mask(1)        ! Pointer to Dirichlet BCs
      integer nx,ny,nz,l
      real w(nx,ny,nz,nel)
      
      integer e,count,ptr
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      zero = 0
      nxyz = nx*ny*nz
      n    = nx*ny*nz*nel

      call rone(w,n)   ! Init everything to 1

      ierr = 0
      ierrmx = 0       ! BC verification
      two    = 2
      ifield = 2
      do e=1,nel       ! Set dirichlet nodes to zero

         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,e,two,ierr)

c        write(6,6) e,lbr,rbr,lbs,rbs,ierr,nx
c   6    format(i5,2x,4i3,2x,i2,3x,i5,'  lbr,rbr,lbs')

         if (lbr.eq.1) call facev(w,e,4,zero,nx,ny,nz)
         if (rbr.eq.1) call facev(w,e,2,zero,nx,ny,nz)
         if (lbs.eq.1) call facev(w,e,1,zero,nx,ny,nz)
         if (rbs.eq.1) call facev(w,e,3,zero,nx,ny,nz)
         if (if3d) then
            if (lbt.eq.1) call facev(w,e,5,zero,nx,ny,nz)
            if (rbt.eq.1) call facev(w,e,6,zero,nx,ny,nz)
         endif
         ierrmx = max(ierrmx,ierr)
      enddo

c     call hsmg_dsprod(w,l)    ! direct stiffness multiply
      call adfmg_dsprod(w,l)    ! direct stiffness multiply

c     write(6,*) 'w l ',(w(i,1,1,1),i=1,nx*ny*nel)
c
c     Prototypical mask layout, nel=5:
c
c    e=1 ...             10
c      1  2  3  4  5 ... 10 | 11 12 13 14 | 15 | 16 |
c     11 15 16 ...          |  3 p1 p2 p3 |  0 |  0 | ...
c                              ^
c                              |
c                              |_count for e=1
c

      nm  = 1                  ! store mask
      do e=1,nel

         mask(e) = nel+nm
         count   = 0          ! # Dirchlet points on element e
         ptr     = mask(e)

         do i=1,nxyz
            if (w(i,1,1,e).eq.0) then
               nm    = nm   +1
               count = count+1
               ptr   = ptr  +1
               mask(ptr) = i + nxyz*(e-1)   ! where I mask on element e 
            endif
         enddo


         ptr       = mask(e)
         mask(ptr) = count

         nm        = nm+1     ! bump pointer to hold next count

      enddo

      nm = nel + nm-1 ! Return total number of mask pointers/counters

      ierrmx = iglmax(ierrmx,1)
      if (ierrmx.gt.0) then
         if ((ierr.gt.0).and.(nio.eq.0))
     $   write(6,*) nid,ierr,' BC FAIL h1'
         call exitti('D INVALID BC FOUND in adfmg_setup_mask$',ierrmx)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_set_h1  (p_h1 ,l0)
      include 'SIZE'
      include 'HSMGL'
      include 'INPUT'
      integer pf,pc

c     As a first pass, rely on the cheesy common-block interface to get h1

      common /scrvh/ h2    (lx1,ly1,lz1,lelv)
     $             , h2inv (lx1,ly1,lz1,lelv)

      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1
      real htmp(lx1*ly1*lz1*lelt)

      integer p_h1

      l                 = mg_h1_lmax
      p_mg_h1(l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)

      call svisc(htmp,2)
      if (nio.eq.0) write (6,*)
     $   'adfmg_set_h1: changing viscosity in',2,htmp(1)
      call copy(mg_h1,htmp,n)   ! Fine grid is just original h1

      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)

      do l=mg_h1_lmax-1,1,-1

         p_mg_h1(l,mg_fld) = p_mg_h1(l+1,mg_fld) + n
         n                 = mg_h1_n(l  ,mg_fld)

         pf                = p_mg_h1(l+1,mg_fld)
         pc                = p_mg_h1(l  ,mg_fld)

         call adfmg_intp_fc (mg_h1(pc),mg_h1(pf),l)

      enddo

      p_h1 = p_mg_h1(l0,mg_fld)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_set_h2  (p_h2 ,l0)
      include 'SIZE'
      include 'HSMGL'

c     As a first pass, rely on the cheesy common-block interface to get h2

      common /scrvh/ h2    (lx1,ly1,lz1,lelv)
     $             , h2inv (lx1,ly1,lz1,lelv)

      common /adfcoef/ h1(lx1*ly1*lz1*lelt)
      real             h1

      integer p_h2,pf,pc

      l                 = mg_h1_lmax
      p_mg_h2(l,mg_fld) = 0
      n                 = mg_h1_n(l,mg_fld)

      call copy (mg_h2,h2,n)   ! Fine grid is just original h2

      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)

      do l=mg_h1_lmax-1,1,-1

         p_mg_h2(l,mg_fld) = p_mg_h2(l+1,mg_fld) + n
         n                 = mg_h1_n(l  ,mg_fld)

         pf                = p_mg_h2(l+1,mg_fld)
         pc                = p_mg_h2(l  ,mg_fld)

         call adfmg_intp_fc (mg_h2(pc),mg_h2(pf),l)

      enddo

      p_h2 = p_mg_h2(l0,mg_fld)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfamg_setup_nx(lv)
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'

      mg_fld = ifield                    ! FIELD pointer

      mg_h1_lmax        = lv
      mg_lmax           = mg_h1_lmax

      ! test two level
c     mg_h1_lmax        = 2
c     mg_lmax           = mg_h1_lmax

      if  ( param(80).gt.0.5 ) then
         ! Schedule: divide by 2
         mg_nx(mg_h1_lmax) = lx1-1        ! Polynomial degree 
         do k = mg_h1_lmax-1, 1,-1       ! of multigrid levels
            mg_nx(k) = (mg_nx(k+1)+1)/2-1
         enddo
      else
         ! Schedule: minus 2
         mg_nx(mg_h1_lmax) = lx1-1        ! Polynomial degree 
         do k = mg_h1_lmax-1, 1,-1       ! of multigrid levels
            mg_nx(k) = mg_nx(k+1)-2
         enddo
      endif

c     if(mg_nx(1).eq.1) then
c       mg_nx(1) = 2 ! avoid linear for now
c     endif

      call icopy(mg_ny, mg_nx, mg_h1_lmax)
      call icopy(mg_nz, mg_nx, mg_h1_lmax)
      if (ldim.eq.2) call izero(mg_nz, mg_h1_lmax)

      if (nio.eq.0) then
         write(6, *) 'adf_mg_nx:', (mg_nx(i), i = 1, mg_h1_lmax)
         write(6, *) 'adf_mg_ny:', (mg_ny(i), i = 1, mg_h1_lmax)
         write(6, *) 'adf_mg_nz:', (mg_nz(i), i = 1, mg_h1_lmax)
      endif

      do ifld=1,ldimt1
      do l=1,mg_lmax
         mg_h1_n(l, ifld) = (mg_nx(l) + 1) * 
     $                      (mg_ny(l) + 1) *
     $                      (mg_nz(l) + 1) * 
     $                      nelfld(ifld) ! vector length on each level
      enddo
      enddo
c     if(nio.eq.0) then
c     do l=1,mg_lmax
c     write(6,*) 'adf h1 n:',mg_h1_n(l,2),'=(',mg_nx(l),'+1)^2 *'
c    $           ,nelfld(2),' ?'
c     enddo
c     endif

c     S-matrix size
      nxxs  = 0
      nxyzs = 0
      do l=1,mg_lmax
         nxx  = (mg_nx(l)+1)**2
         nxyz = (mg_nx(l)+1)*(mg_ny(l)+1)*(mg_nz(l)+1)
         nxxs = nxxs + nxx
         nxyzs= nxyzs + nxyz
      enddo

      if (nio.eq.0) then
       write(6,*) nxxs ,lmg_fasts,'  mg: S-matrix sizes (used, alloc)'
       write(6,*) nxyzs,lmg_g    ,'  mg: G-matrix sizes (used, alloc)'
      endif
      if(nxyzs.gt.lmg_g)call exitti('ERROR: Increase lmg_g to:$',nxyzs)
      if(nxxs.gt.lmg_fasts)call exitti('Increase lmg_fasts to:$',nxxs)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_axm(w,p,aw,ap,l,wk)
c
c     w  := aw*w + ap*H*p, level l, with mask and dssum
c
c     Hu := div. h1 grad u + h2 u
c
c        ~= h1 A u + h2 B u
c
c     Here, we assume that pointers into g() and h1() and h2() have
c     been established
c
      include 'SIZE'
      include 'HSMGL'
      include 'TSTEP'  ! nelfld

      real w(1),p(1),wk(1)

      integer p_h1,p_h2,p_g,p_b,p_msk, p_c
      logical ifh2
      common /adfco/  co
      real            co(lmg_g*(ldim)*lelt) ! big enough?
      common /adfcoi/ pco
      integer         pco(lmgx,ldimt1) ! big enough?

      real aw, ap

      p_h1  = p_mg_h1  (l,mg_fld)
      p_h2  = p_mg_h2  (l,mg_fld)
      p_g   = p_mg_g   (l,mg_fld)
      p_b   = p_mg_b   (l,mg_fld)
      p_msk = p_mg_msk (l,mg_fld)
c     write(6,*) 'inside adfmg axm:: p_msk',p_msk,l
      p_c   = pco      (l,mg_fld) ! right

      if (p_h1 .eq.0) call adfmg_set_h1  (p_h1 ,l)
      if (p_h2 .eq.0) call adfmg_set_h2  (p_h2 ,l)
      if (p_g  .eq.0) call adfmg_set_gb  (p_g,p_b,l)
      if (p_msk.eq.0) call adfmg_set_msk (p_msk,l)
      if (p_c  .eq.0) call adfmg_set_co  (p_c,l)

      ifh2 = .false.

      nx = mg_nh(l)
      ny = mg_nh(l)
      nz = mg_nhz(l)
      ng = 3*ldim-3
      nc = ldim

      ! update to have c !
      call adfmg_axml (wk,p
     $               ,mg_h1(p_h1),mg_h2(p_h2),nx,ny,nz,nelfld(ifield)
     $               ,mg_g (p_g) , ng ,mg_b(p_b), mg_imask(p_msk),ifh2
     $               , co(p_c), nc)

      ! wk = C p + A p

c     n = nx*ny*nz*nelfld(ifield)
      n = nx*ny*nz*nelfld(mg_fld)
      call adfmg_dssum  (wk,l) ! hsmg_dssum
      ! w = aw * w + ap * wk = 1 * w - 1 * wk = w - ( C p + A p)
      call add2sxy    (w,aw,wk,ap,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_axml
     $  (w,p,h1,h2,nx,ny,nz,nel,g,ng,b,mask,ifh2,c,nc)
c
c     w  := aw*w + ap*H*p, level l, with mask and dssum
c
c     Hu := div. h1 grad u + h2 u
c
c        ~= h1 A u + h2 B u
c

      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'

      real w (nx*ny*nz,nel), p (nx*ny*nz,nel)
     $   , h1(nx*ny*nz,nel), h2(nx*ny*nz,nel)
     $   , b (nx*ny*nz,nel), g (ng*nx*ny*nz,nel)
      real c (nc*nx*ny*nz,nel)
      integer nc
      integer mask(1)

      logical ifh2

      parameter (lxyz=lx1*ly1*lz1)
      common /ctmp0/ ur(lxyz),us(lxyz),ut(lxyz)

      integer e

      do e=1,nel

         call adf_axe(w(1,e),p(1,e),h1(1,e),h2(1,e),g(1,e),ng,b(1,e)
     $            ,nx,ny,nz,ur,us,ut,ifh2,e,c(1,e),nc)
   
         im = mask(e)
         call adfmg_mask_e(w,mask(im)) ! Zero out Dirichlet conditions

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_axe
     $     (w,p,h1,h2,g,ng,b,nx,ny,nz,ur,us,ut,ifh2,e,c,nc) !

      include 'SIZE'
      include 'INPUT'   ! if3d
      logical ifh2

      real w (nx*ny*nz), p (nx*ny*nz)
     $   , h1(nx*ny*nz), h2(nx*ny*nz)
     $   , b (nx*ny*nz), g (ng,nx*ny*nz)
     $   , ur(nx*ny*nz), us(nx*ny*nz), ut(nx*ny*nz)
      real c (nc,nx*ny*nz)
      integer e

      real tmp(lx1*ly1*lz1) ! largest size for one e

      nxyz = nx*ny*nz

      call gradl_rst(ur,us,ut,p,nx,if3d)

      if(ldim.eq.3) then
        do i=1,nxyz
          tmp(i) = c(1,i)*ur(i) + c(2,i)*us(i) + c(3,i)*ut(i)
        enddo
      else ! 2D
        do i=1,nxyz
          tmp(i) = c(1,i)*ur(i) + c(2,i)*us(i)
        enddo
      endif

      if (if3d) then
         do i=1,nxyz
            wr = g(1,i)*ur(i) + g(4,i)*us(i) + g(5,i)*ut(i)
            ws = g(4,i)*ur(i) + g(2,i)*us(i) + g(6,i)*ut(i)
            wt = g(5,i)*ur(i) + g(6,i)*us(i) + g(3,i)*ut(i)
            ur(i) = wr*h1(i)
            us(i) = ws*h1(i)
            ut(i) = wt*h1(i)
         enddo
      else ! if2d
         do i=1,nxyz
            wr = g(1,i)*ur(i) + g(3,i)*us(i)
            ws = g(3,i)*ur(i) + g(2,i)*us(i)
            ur(i) = wr*h1(i)
            us(i) = ws*h1(i)
         enddo
      endif

      call gradl_rst_t(w,ur,us,ut,nx,if3d)

      ! add in advection
      call add2(w,tmp,nxyz)

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwarz_wt(e,l)
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      
      if(.not.if3d) call adfmg_schwarz_wt2d(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      if(if3d) call adfmg_schwarz_wt3d(
     $    e,mg_schwarz_wt(mg_schwarz_wt_index(l,mg_fld)),mg_nh(l))
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwarz_wt2d(e,wt,n)
      include 'SIZE'
      integer n
      real e(n,n,nelt)
      real wt(n,4,2,nelt)
      
      integer ie,i,j
      do ie=1,nelt
         do j=1,n
            e(1  ,j,ie)=e(1  ,j,ie)*wt(j,1,1,ie)
            e(2  ,j,ie)=e(2  ,j,ie)*wt(j,2,1,ie)
            e(n-1,j,ie)=e(n-1,j,ie)*wt(j,3,1,ie)
            e(n  ,j,ie)=e(n  ,j,ie)*wt(j,4,1,ie)
         enddo
         do i=3,n-2
            e(i,1  ,ie)=e(i,1  ,ie)*wt(i,1,2,ie)
            e(i,2  ,ie)=e(i,2  ,ie)*wt(i,2,2,ie)
            e(i,n-1,ie)=e(i,n-1,ie)*wt(i,3,2,ie)
            e(i,n  ,ie)=e(i,n  ,ie)*wt(i,4,2,ie)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwarz_wt3d(e,wt,n)
      include 'SIZE'
      integer n
      real e(n,n,n,nelt)
      real wt(n,n,4,3,nelt)
      
      integer ie,i,j,k
      do ie=1,nelt
         do k=1,n
         do j=1,n
            e(1  ,j,k,ie)=e(1  ,j,k,ie)*wt(j,k,1,1,ie)
            e(2  ,j,k,ie)=e(2  ,j,k,ie)*wt(j,k,2,1,ie)
            e(n-1,j,k,ie)=e(n-1,j,k,ie)*wt(j,k,3,1,ie)
            e(n  ,j,k,ie)=e(n  ,j,k,ie)*wt(j,k,4,1,ie)
         enddo
         enddo
         do k=1,n
         do i=3,n-2
            e(i,1  ,k,ie)=e(i,1  ,k,ie)*wt(i,k,1,2,ie)
            e(i,2  ,k,ie)=e(i,2  ,k,ie)*wt(i,k,2,2,ie)
            e(i,n-1,k,ie)=e(i,n-1,k,ie)*wt(i,k,3,2,ie)
            e(i,n  ,k,ie)=e(i,n  ,k,ie)*wt(i,k,4,2,ie)
         enddo
         enddo
         do j=3,n-2
         do i=3,n-2
            e(i,j,1  ,ie)=e(i,j,1  ,ie)*wt(i,j,1,3,ie)
            e(i,j,2  ,ie)=e(i,j,2  ,ie)*wt(i,j,2,3,ie)
            e(i,j,n-1,ie)=e(i,j,n-1,ie)*wt(i,j,3,3,ie)
            e(i,j,n  ,ie)=e(i,j,n  ,ie)*wt(i,j,4,3,ie)
         enddo
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_dssum(u,l)
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'
      real u(1)

      if (ifsync) call nekgsync()
      etime1=dnekclock()

      call fgslib_gs_op(mg_gsh_handle(l,mg_fld),u,1,1,0)
      tdadd =tdadd + dnekclock()-etime1


      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_dsprod(u,l)
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'
      real u(1)

      if (ifsync) call nekgsync()

      call fgslib_gs_op(mg_gsh_handle(l,mg_fld),u,1,2,0)
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_schwarz_dssum(u,l)
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      if (ifsync) call nekgsync()
      etime1=dnekclock()

      call fgslib_gs_op(mg_gsh_schwarz_handle(l,mg_fld),u,1,1,0)
      tdadd =tdadd + dnekclock()-etime1

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_mask(w,mask,nel)
      include 'SIZE'

      real    w   (1)
      integer mask(1)        ! Pointer to Dirichlet BCs
      integer e
      
      do e=1,nel
         im = mask(e)
c        write(6,*) e,im,mask(im),'im in adfmg mask'
         call adfmg_mask_e(w,mask(im)) ! Zero out Dirichlet conditions
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adfmg_intp_fc(uc,uf,l) ! l is coarse level

      include 'SIZE'
      include 'HSMGL'

      real uc(1),uf(1)


      nc = mg_nh(l)
      nf = mg_nh(l+1)
      call adfmg_tnsr(uc,nc,uf,nf,mg_jhfc(1,l),mg_jhfct(1,l))

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_intp(uf,uc,l) ! l is coarse level
      real uf(1),uc(1)
      integer l
      include 'SIZE'
      include 'HSMGL'
      call adfmg_tnsr(uf,mg_nh(l+1),uc,mg_nh(l),mg_jh(1,l),mg_jht(1,l))
      return
      end
c------------------------------------------   T  -----------------------
      subroutine adfmg_rstr(r,l,ifdssum) ! r =J r,   l is coarse level
      include 'SIZE'
      include 'HSMGL'
      logical ifdssum

      real r(1)
      integer l

      call adfmg_do_wt(r,mg_rstr_wt(mg_rstr_wt_index(l+1,mg_fld))
     $                     ,mg_nh(l+1),mg_nh(l+1),mg_nhz(l+1))

      call adfmg_tnsr1(r,mg_nh(l),mg_nh(l+1),mg_jht(1,l),mg_jh(1,l))

      if (ifdssum) call adfmg_dssum(r,l)

      return
      end
c----------------------------------------------------------------------
c     computes
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
      subroutine adfmg_tnsr(v,nv,u,nu,A,At)
      integer nv,nu
      real v(1),u(1),A(1),At(1)
      include 'SIZE'
      include 'INPUT'
      if (.not. if3d) then
         call adfmg_tnsr2d(v,nv,u,nu,A,At)
      else
         call adfmg_tnsr3d(v,nv,u,nu,A,At,At)
      endif
      return
      end
c----------------------------------------------------------------------
c     computes
c              T
c     v = A u B
      subroutine adfmg_tnsr2d(v,nv,u,nu,A,Bt)
      integer nv,nu
      real v(nv*nv,nelt),u(nu*nu,nelt),A(1),Bt(1)
      include 'SIZE'
      common /hsmgw/ work((lx1+2)*(lx1+2))
      integer ie
      do ie=1,nelt
         call mxm(A,nv,u(1,ie),nu,work,nu)
         call mxm(work,nv,Bt,nu,v(1,ie),nv)
      enddo
      return
      end
c----------------------------------------------------------------------
c     computes
c              
c     v = [C (x) B (x) A] u
      subroutine adfmg_tnsr3d(v,nv,u,nu,A,Bt,Ct)
      integer nv,nu
      real v(nv*nv*nv,nelt),u(nu*nu*nu,nelt),A(1),Bt(1),Ct(1)
      include 'SIZE'
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      integer ie, i
      do ie=1,nelt
         call mxm(A,nv,u(1,ie),nu,work,nu*nu)
         do i=0,nu-1
            call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
         enddo
         call mxm(work2,nv*nv,Ct,nu,v(1,ie),nv)
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_tnsr1(v,nv,nu,A,At)
c
c     v = [A (x) A] u      or
c     v = [A (x) A (x) A] u 
c
      integer nv,nu
      real v(1),A(1),At(1)
      include 'SIZE'
      include 'INPUT'
      if (.not. if3d) then
         call adfmg_tnsr1_2d(v,nv,nu,A,At)
      else
         call adfmg_tnsr1_3d(v,nv,nu,A,At,At)
      endif
      return
      end
c-------------------------------------------------------T--------------
      subroutine adfmg_tnsr1_2d(v,nv,nu,A,Bt) ! u = A u B
      integer nv,nu
      real v(1),A(1),Bt(1)
      include 'SIZE'
      common /hsmgw/ work(lx1*lx1)
      integer e

      nv2 = nv*nv
      nu2 = nu*nu

      if (nv.le.nu) then
         iv=1
         iu=1
         do e=1,nelt
            call mxm(A,nv,v(iu),nu,work,nu)
            call mxm(work,nv,Bt,nu,v(iv),nv)
            iv = iv + nv2
            iu = iu + nu2
         enddo
      else
         do e=nelt,1,-1
            iu=1+nu2*(e-1)
            iv=1+nv2*(e-1)
            call mxm(A,nv,v(iu),nu,work,nu)
            call mxm(work,nv,Bt,nu,v(iv),nv)
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_tnsr1_3d(v,nv,nu,A,Bt,Ct) ! v = [C (x) B (x) A] u
      integer nv,nu
      real v(1),A(1),Bt(1),Ct(1)
      include 'SIZE'
      parameter (lwk=(lx1+2)*(ly1+2)*(lz1+2))
      common /hsmgw/ work(0:lwk-1),work2(0:lwk-1)
      integer e,e0,ee,es

      e0=1
      es=1
      ee=nelt

      if (nv.gt.nu) then
         e0=nelt
         es=-1
         ee=1
      endif

      nu3 = nu**3
      nv3 = nv**3

      do e=e0,ee,es
         iu = 1 + (e-1)*nu3
         iv = 1 + (e-1)*nv3
         call mxm(A,nv,v(iu),nu,work,nu*nu)
         do i=0,nu-1
            call mxm(work(nv*nu*i),nv,Bt,nu,work2(nv*nv*i),nv)
         enddo
         call mxm(work2,nv*nv,Ct,nu,v(iv),nv)
      enddo

      return
      end
c----------------------------------------------------------------------
c     u = wt .* u
      subroutine adfmg_do_wt(u,wt,nx,ny,nz)
      include 'SIZE'
      include 'INPUT'
      integer nx,ny,nz
      real u(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)
      
      integer e

c     if (nx.eq.2) then
c        do e=1,nelt
c           call outmat(wt(1,1,1,1,e),nx,nz,'wt 1-1',e)
c           call outmat(wt(1,1,2,1,e),nx,nz,'wt 2-1',e)
c           call outmat(wt(1,1,1,2,e),nx,nz,'wt 1-2',e)
c           call outmat(wt(1,1,2,2,e),nx,nz,'wt 2-2',e)
c        enddo
c        call exitti('hsmg_do_wt quit$',nelt)
c     endif

      if (.not. if3d) then
         do ie=1,nelt
            do j=1,ny
               u( 1,j,1,ie)=u( 1,j,1,ie)*wt(j,1,1,1,ie)
               u(nx,j,1,ie)=u(nx,j,1,ie)*wt(j,1,2,1,ie)
            enddo
            do i=2,nx-1
               u(i, 1,1,ie)=u(i, 1,1,ie)*wt(i,1,1,2,ie)
               u(i,ny,1,ie)=u(i,ny,1,ie)*wt(i,1,2,2,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=1,nz
            do j=1,ny
               u( 1,j,k,ie)=u( 1,j,k,ie)*wt(j,k,1,1,ie)
               u(nx,j,k,ie)=u(nx,j,k,ie)*wt(j,k,2,1,ie)
            enddo
            enddo
            do k=1,nz
            do i=2,nx-1
               u(i, 1,k,ie)=u(i, 1,k,ie)*wt(i,k,1,2,ie)
               u(i,ny,k,ie)=u(i,ny,k,ie)*wt(i,k,2,2,ie)
            enddo
            enddo
            do j=2,ny-1
            do i=2,nx-1
               u(i,j, 1,ie)=u(i,j, 1,ie)*wt(i,j,1,3,ie)
               u(i,j,nz,ie)=u(i,j,nz,ie)*wt(i,j,2,3,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_mask_e(w,mask) ! Zero out Dirichlet conditions
      include 'SIZE'
      real w(1)
      integer mask(0:1)

      n=mask(0)
      do i=1,n
c        write(6,*) i,mask(i),n,' MG_MASK'
         w(mask(i)) = 0.
      enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_outpost(b,l)
      include 'SIZE'
      include 'TOTAL'
      include 'HSMGL'
      integer n
      real    b(1)
      
      common  /adfoutp/ tmp
      real              tmp(lx1*ly1*lz1*lelt*lmgn)
      integer i,j,ie

      if(l.eq.mg_h1_lmax) then
        call outpost(vx,vy,vz,pr,b,'   ')
        return
      endif

      is = 1
      do il=l,mg_h1_lmax-1
        if(il.eq.l) then ! first pass
          call adfmg_intp(tmp(is),b,il)
        else
          call adfmg_intp(tmp(is),tmp(im),il)
        endif
        im = is
        n = mg_h1_n(il+1,mg_fld)
        is = is + n
      enddo
      if (nio.eq.0) write(6,*) 'adfmg outpost: orig field level',l
      call outpost(vx,vy,vz,pr,tmp(im),'   ')

      return
      end
c----------------------------------------------------------------------
      subroutine adfmg_debug_coarse(b,n) ! n <= lx1-2
      include 'SIZE'
c     include 'SOLN'
      include 'TOTAL'
      integer n
      real    b(n,n,nelt)
      
      common  /adfdbg/ tmp
      real             tmp(lx1,ly1,lz1,lelt)
      integer i,j,ie

      ntot = nx1*ny1*nz1*nelt
      call rzero(tmp,ntot)
      if(n.eq.nx1) then
        call copy(tmp,b,ntot)
      else if(n.le.lx1-2) then
        call rzero(tmp,ntot)
        do ie=1,nelt
        do j=1,n
        do i=1,n
           tmp(i+1,j+1,1,ie)=b(i,j,ie)
        enddo
        enddo
        enddo
      endif
      write(6,*) 'adfmg debug coarse:',nid,n
      call outpost(vx,vy,vz,pr,tmp,'   ')

      return
      end
c-----------------------------------------------------------------------
c---- Overlapping Schwarz
c----------------------------------------------------------------------
      subroutine adf_schwz_rs(u) ! apply the weights
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      parameter(lt=lx1*ly1*lz1*lelt)
      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)

      real u(1)

      if(ldim.eq.3) then
        call adf_schwarz_rs3d(u,ras_mask,lx1)
      else
        call adf_schwarz_rs2d(u,ras_mask,lx1)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_rs2d(u,mk,n) !
      include 'SIZE'
      integer n
      real u(n,n,nelt)
      real mk(n,n,nelt)
      integer ie,i,j
      integer ntot

      ntot = n*n*nelt
      call col2(u,mk,ntot)

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_rs3d(u,mk,n) !
      include 'SIZE'
      integer n
      real u (n,n,n,nelt)
      real mk(n,n,n,nelt)
c     real wt(n,n,4,3,nelt)
      integer ie,i,j,k
      integer ntot

      ntot = n*n*n*nelt
      call col2(u,mk,ntot)

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_wt(e) ! apply the weights
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      parameter(lt=lx1*ly1*lz1*lelt)
      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)

      real e(1)

      if(.not.if3d) call adf_schwarz_wt2d(e,oswt,lx1)
      if(if3d)      call adf_schwarz_wt3d(e,oswt,lx1)
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_wt2d(e,wt,n) !
      include 'SIZE'
      integer n
      real e(n,n,nelt)
      real wt(n,4,2,nelt)
      integer ie,i,j
      do ie=1,nelt
         do j=1,n
            e(1  ,j,ie)=e(1  ,j,ie)*wt(j,1,1,ie)
            e(2  ,j,ie)=e(2  ,j,ie)*wt(j,2,1,ie)
            e(n-1,j,ie)=e(n-1,j,ie)*wt(j,3,1,ie)
            e(n  ,j,ie)=e(n  ,j,ie)*wt(j,4,1,ie)
         enddo
         do i=3,n-2
            e(i,1  ,ie)=e(i,1  ,ie)*wt(i,1,2,ie)
            e(i,2  ,ie)=e(i,2  ,ie)*wt(i,2,2,ie)
            e(i,n-1,ie)=e(i,n-1,ie)*wt(i,3,2,ie)
            e(i,n  ,ie)=e(i,n  ,ie)*wt(i,4,2,ie)
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_wt3d(e,wt,n) !
      include 'SIZE'
      integer n
      real e(n,n,n,nelt)
      real wt(n,n,4,3,nelt)
      integer ie,i,j,k
      do ie=1,nelt
         do k=1,n
         do j=1,n
            e(1  ,j,k,ie)=e(1  ,j,k,ie)*wt(j,k,1,1,ie)
            e(2  ,j,k,ie)=e(2  ,j,k,ie)*wt(j,k,2,1,ie)
            e(n-1,j,k,ie)=e(n-1,j,k,ie)*wt(j,k,3,1,ie)
            e(n  ,j,k,ie)=e(n  ,j,k,ie)*wt(j,k,4,1,ie)
         enddo
         enddo
         do k=1,n
         do i=3,n-2
            e(i,1  ,k,ie)=e(i,1  ,k,ie)*wt(i,k,1,2,ie)
            e(i,2  ,k,ie)=e(i,2  ,k,ie)*wt(i,k,2,2,ie)
            e(i,n-1,k,ie)=e(i,n-1,k,ie)*wt(i,k,3,2,ie)
            e(i,n  ,k,ie)=e(i,n  ,k,ie)*wt(i,k,4,2,ie)
         enddo
         enddo
         do j=3,n-2
         do i=3,n-2
            e(i,j,1  ,ie)=e(i,j,1  ,ie)*wt(i,j,1,3,ie)
            e(i,j,2  ,ie)=e(i,j,2  ,ie)*wt(i,j,2,3,ie)
            e(i,j,n-1,ie)=e(i,j,n-1,ie)*wt(i,j,3,3,ie)
            e(i,j,n  ,ie)=e(i,j,n  ,ie)*wt(i,j,4,3,ie)
         enddo
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_extrude(arr1,l1,f1,arr2,l2,f2,nx,ny,nz) !
      include 'SIZE'
      include 'INPUT'
      integer l1,l2,nx,ny,nz
      real    arr1(nx,ny,nz,nelt),arr2(nx,ny,nz,nelt)
      real    f1,f2
      integer i,j,k,ie,i0,i1
      i0=2
      i1=nx-1

      if(.not.if3d) then
         do ie=1,nelt
            do j=i0,i1
               arr1(l1+1 ,j,1,ie) = f1*arr1(l1+1 ,j,1,ie)
     $                             +f2*arr2(l2+1 ,j,1,ie)
               arr1(nx-l1,j,1,ie) = f1*arr1(nx-l1,j,1,ie)
     $                             +f2*arr2(nx-l2,j,1,ie)
            enddo
            do i=i0,i1
               arr1(i,l1+1 ,1,ie) = f1*arr1(i,l1+1 ,1,ie)
     $                             +f2*arr2(i,l2+1 ,1,ie)
               arr1(i,ny-l1,1,ie) = f1*arr1(i,ny-l1,1,ie)
     $                             +f2*arr2(i,nx-l2,1,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=i0,i1
            do j=i0,i1
               arr1(l1+1 ,j,k,ie) = f1*arr1(l1+1 ,j,k,ie)
     $                             +f2*arr2(l2+1 ,j,k,ie)
               arr1(nx-l1,j,k,ie) = f1*arr1(nx-l1,j,k,ie)
     $                             +f2*arr2(nx-l2,j,k,ie)
            enddo
            enddo
            do k=i0,i1
            do i=i0,i1
               arr1(i,l1+1 ,k,ie) = f1*arr1(i,l1+1 ,k,ie)
     $                             +f2*arr2(i,l2+1 ,k,ie)
               arr1(i,nx-l1,k,ie) = f1*arr1(i,nx-l1,k,ie)
     $                             +f2*arr2(i,nx-l2,k,ie)
            enddo
            enddo
            do j=i0,i1
            do i=i0,i1
               arr1(i,j,l1+1 ,ie) = f1*arr1(i,j,l1+1 ,ie)
     $                             +f2*arr2(i,j,l2+1 ,ie)
               arr1(i,j,nx-l1,ie) = f1*arr1(i,j,nx-l1,ie)
     $                             +f2*arr2(i,j,nx-l2,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_lu(x,r) !
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'
      parameter(ls=lx1+2)

      common /adfscbn/ Lb
      real             Lb(ls**ldim,ls**ldim,lelt)  ! system to solve
      common /adfiarn/ ipiv ! integer array
      integer          ipiv(ls**ldim,lelt)   ! pivot index

      real    lbe(ls**ldim,ls**ldim)   ! to not overwrite Lb
      integer info       ! return information
      real    x(ls**ldim,1), r(ls**ldim,1) ! 3D declaration
      character*1 tr

      integer ilufcd  ! flag for whether already LU factored
      data    ilufcd / 0 /
      save    ilufcd

      ns  = ls**ldim
      nst = ns*nelt

      ! only factor once
      tr = 'N' ! no transpose
      if(ilufcd.eq.0) then
        if(nio.eq.0) write(6,*) 'Schwarz: LU factoring...'
        do ie=1,nelt
          call dgetrf(ns,ns,Lb(1,1,ie),ns,ipiv(1,ie),info) ! LU
          if(info.ne.0) write(6,*) 'issue in dgetrf',ie

          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,Lb(1,1,ie),ns,ipiv(1,ie),x(1,ie),ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie
        enddo
        ilufcd = 1
      else if(ilufcd.eq.1) then ! already factored, only need to solve
        do ie=1,nelt
          call copy(x(1,ie),r(1,ie),ns)
          call dgetrs(tr,ns,1,Lb(1,1,ie),ns,ipiv(1,ie),x(1,ie),ns,info)
          if(info.ne.0) write(6,*) 'issue in dgetrs',ie
        enddo
      endif

      ! re-factor every time
c     do ie=1,nelt
c       call copy(lbe,Lb(1,1,ie),ns*ns) ! do not overwrite Lb
c       call copy(x(1,ie),r(1,ie),ns)
c       call dgesv(ns,1,lbe,ns,ipiv(1,ie),x(1,ie),ns,info)
c       if(info.ne.0)
c    $     write(6,*) 'issue in dgesv',ie
c     enddo

      return
      end
c----------------------------------------------------------------------
      subroutine adf_dssum(u) ! Schwarz dssum handle
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      common /adfsci/ adfsc_handle, t_handle
      integer         adfsc_handle, t_handle

      if (ifsync) call nekgsync()
      etime1=dnekclock()

      call fgslib_gs_op(t_handle,u,1,1,0)
      ! - when vel bc and scalar bc agrees, this makes no difference
      ! - when vel bc and scalar bc differs, this is different
      ! test
c     call dssum(u,lx1,ly1,lz1)

      tdadd =tdadd + dnekclock()-etime1

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_dssum(u) ! Schwarz dssum handle
      include 'SIZE'
      include 'HSMGL'
      include 'CTIMER'

      common /adfsci/ adfsc_handle, t_handle
      integer         adfsc_handle, t_handle

      if (ifsync) call nekgsync()
      etime1=dnekclock()

      call fgslib_gs_op(adfsc_handle,u,1,1,0)

      tdadd =tdadd + dnekclock()-etime1

      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_toext2d(a,b,n)
      include 'SIZE'
      integer n
      real    a(0:n+1,0:n+1,nelt),b(n,n,nelt)
      integer i,j,ie
c      call rzero(a,(n+2)*(n+2)*nelt)
      do ie=1,nelt
         do i=0,n+1
            a(i,0,ie)=0.
         enddo
         do j=1,n
            a(0  ,j,ie)=0.
            do i=1,n
               a(i,j,ie)=b(i,j,ie)
            enddo
            a(n+1,j,ie)=0.
         enddo
         do i=0,n+1
            a(i,n+1,ie)=0.
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_toext3d(a,b,n)
      include 'SIZE'
      real    a(0:n+1,0:n+1,0:n+1,nelt),b(n,n,n,nelt)
      integer n
      integer i,j,k,ie
      call rzero(a,(n+2)*(n+2)*(n+2)*nelt)
      do ie=1,nelt
      do k=1,n
      do j=1,n
      do i=1,n
         a(i,j,k,ie)=b(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_toreg2d(b,a,n)
      include 'SIZE'
      integer n
      real    a(0:n+1,0:n+1,nelt),b(n,n,nelt)
      integer i,j,ie
      do ie=1,nelt
      do j=1,n
      do i=1,n
         b(i,j,ie)=a(i,j,ie)
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_schwarz_toreg3d(b,a,n)
      include 'SIZE'
      integer n
      real    a(0:n+1,0:n+1,0:n+1,nelt),b(n,n,n,nelt)
      integer i,j,k,ie
      do ie=1,nelt
      do k=1,n
      do j=1,n
      do i=1,n
         b(i,j,k,ie)=a(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_dssum_t
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'HSMGL'
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)

      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l

      common /adfsci/ adfsc_handle, t_handle
      integer         adfsc_handle, t_handle

      ncrnr = 2**ldim
      call get_vert

      nx=nx1
      ny=ny1
      nz=nz1
      if(.not.if3d) nz=1
      call setupds(t_handle,nx,ny,nz
     $                ,nelt,nelgt,vertex,glo_num)

      return
      end
c----------------------------------------------------------------------
      subroutine adfs_setup_dssum
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'HSMGL'
      parameter (lxyz=(lx1+2)*(ly1+2)*(lz1+2))
      common /c_is1/ glo_num(lxyz*lelt)
      common /ivrtx/ vertex ((2**ldim)*lelt)

      integer*8 glo_num
      integer vertex
      integer nx,ny,nz
      integer l

      common /adfsci/ adfsc_handle, t_handle
      integer         adfsc_handle, t_handle

      ! need this, should work
      ncrnr = 2**ldim
      call get_vert

      nx=nx1+2
      ny=ny1+2
      nz=nz1+2
      if(.not.if3d) nz=1
      call setupds(adfsc_handle,nx,ny,nz
     $                ,nelt,nelgt,vertex,glo_num)

      return
      end
c----------------------------------------------------------------------
      subroutine adfs_setup_semhat ! SEM hat matrices for one level
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'
      include 'SEMHAT'

      parameter(lh=lx1)
      common /adfsch/ as_ah, as_bh, as_ch, as_dh, as_dht, as_zh
      real    as_ah(lh,lh), as_bh(lh)
     $      , as_ch(lh,lh), as_dh(lh,lh), as_dht(lh,lh)
     $      , as_zh(lh)

      n = lx1 - 1 ! polynomial order assumed to be lx1-1

      call semhat(ah,bh,ch,dh,zh,dph,jph,bgl,zglhat,dgl,jgl,n,wh)

      call copy(as_ah,ah,(n+1)*(n+1))
      call copy(as_bh,bh,n+1)
      call copy(as_dh,dh,(n+1)*(n+1))
      call copy(as_ch,ch,(n+1)*(n+1))
      call transpose(as_dht,n+1,dh,n+1)
      call copy(as_zh,zh,n+1)

      end
c----------------------------------------------------------------------
      subroutine adf_setup_wtmask() ! returns regular size masks
      include 'SIZE'
      include 'HSMGL'
      parameter(lt=lx1*ly1*lz1*lelt)
      integer l
      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)
      real wk(lt)
      common /logmn/ ifrstr
      logical        ifrstr

      nx = lx1
      ny = ly1
      nz = lz1
      if(ldim.eq.2) nz=1

      call adf_setup_rstr_wt(as_rstr_wt,nx,ny,nz,l,wk)

      ! i don't think as_mask is even used
      !  this routine call does not affect Schwarz
      !  as it stands

      if(ifrstr) then ! restricted AS
        call adf_setup_mask_rt(as_mask,ras_mask,nx,ny,nz,l,wk)
        ! write out as_mask
c       do ie=1,nelt
c         write(6,*) ie,' , e mask v'
c         write(6,*) (ras_mask(i,1,1,ie),i=1,lx1*ly1*lz1)
c       enddo
      else
        call adf_setup_mask   (as_mask,nx,ny,nz,l,wk)
        ! write out as_mask
c       do ie=1,nelt
c         write(6,*) ie,' , e mask'
c         write(6,*) (as_mask(i,1,1,ie),i=1,lx1*1*2*2)
c       enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_rstr_wt(wt,nx,ny,nz,l,w)
      include 'SIZE'
      include 'INPUT'
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)

      integer ie
      !init border nodes to 1
      call rzero(w,nx*ny*nz*nelt)
c     print *, 'Setup rstr wt: ',nx,ny,nz,nelt
      if (.not.if3d) then
         do ie=1,nelt
            do i=1,nx
               w(i,1,1,ie)=1.0
               w(i,ny,1,ie)=1.0
            enddo
            do j=1,ny
               w(1,j,1,ie)=1.0
               w(nx,j,1,ie)=1.0
            enddo
         enddo
      else
         do ie=1,nelt
            do j=1,ny
            do i=1,nx
               w(i,j,1,ie)=1.0
               w(i,j,nz,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=1.0
               w(i,ny,k,ie)=1.0
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=1.0
               w(nx,j,k,ie)=1.0
            enddo
            enddo
         enddo
      endif
      call adf_dssum(w)
      !invert the count w to get the weight wt
      if (.not. if3d) then
         do ie=1,nelt
            do j=1,ny
               wt(j,1,1,1,ie)=1.0/w(1,j,1,ie)
               wt(j,1,2,1,ie)=1.0/w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=1.0/w(i,1,1,ie)
               wt(i,1,2,2,ie)=1.0/w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=1.0/w(1,j,k,ie)
               wt(j,k,2,1,ie)=1.0/w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=1.0/w(i,1,k,ie)
               wt(i,k,2,2,ie)=1.0/w(i,ny,k,ie)
            enddo
            enddo
            do j=1,ny
            do i=1,nx
               wt(i,j,1,3,ie)=1.0/w(i,j,1,ie)
               wt(i,j,2,3,ie)=1.0/w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_mask_rt(wt,wv,nx,ny,nz,l,w) ! No 3D
      include 'SIZE'
      include 'INPUT'
      include 'SOLN' ! for outpost debugging only, remove later!
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelt)
      real wv(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)

      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two

      n = nx*ny*nz*nelt
      call rone(w,n)
      call rone(wv,n)

      nf = nx*nz*2*ndim*nelt
      call rone(wt,nf)

c     set neumann nodes to zero
      ierr = 0
      two  = 2
      do ie=1,nelt
        ! general case
        call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        if (ierr.ne.0) then
           ierr = -1
           call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
        endif
        sumbc = lbr+rbr+lbs+rbs
        if(sumbc.gt.4)
     $  write(6,*) ie,lbr,rbr,lbs,rbs,' fast bcs'
        if(ldim.eq.3) then ! 3D NOT TESTED !
          iz0=2
          if(lbt.eq.2) iz0 = 1
          iz1=nz-1
          if(rbt.eq.2) iz1 = nz
          if(lbr.eq.2) then !
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(1,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbr.eq.2) then
            iy0 = 2
            if(lbs.eq.2) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.2) iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(nx,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(lbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,1,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbs.eq.2) then
            ix0 = 2
            if(lbr.eq.2) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.2) ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,ny,k,ie) = 0.
            enddo
            enddo
          endif
          ix0=2
          if(lbr.eq.2) ix0=1
          ix1=nx-1
          if(lbr.eq.2) ix1=nx
          iy0=2
          if(lbr.eq.2) iy0=1
          iy1=ny-1
          if(lbr.eq.2) iy1=ny
          if(lbt.eq.2) then
            do j=iy0,iy1
            do i=ix0,ix1
              wv(i,j,1,ie) = 0.
            enddo
            enddo
          endif
          if(rbt.eq.2) then
            do j=iy0,iy1
            do i=ix0,ix1
              wv(i,j,nz,ie) = 0.
            enddo
            enddo
          endif
        else ! 2D
          iz0 = 1
          iz1 = nz
          if(lbr.eq.3) then !
            iy0 = 2
            if(lbs.eq.3) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.3) iy1 = ny
            ! ! dir-neum corner becomes neum
            ! iy0 = 1
            ! iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(1,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbr.eq.3) then
            iy0 = 2
            if(lbs.eq.3) iy0 = 1
            iy1 = ny-1
            if(rbs.eq.3) iy1 = ny
            ! iy0 = 1
            ! iy1 = ny
            do k=iz0,iz1
            do j=iy0,iy1
              wv(nx,j,k,ie) = 0.
            enddo
            enddo
          endif
          if(lbs.eq.3) then
            ix0 = 2
            if(lbr.eq.3) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.3) ix1 = nx
            ! ix0 = 1
            ! ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,1,k,ie) = 0.
            enddo
            enddo
          endif
          if(rbs.eq.3) then
            ix0 = 2
            if(lbr.eq.3) ix0 = 1
            ix1 = nx-1
            if(rbr.eq.3) ix1 = nx
            ! ix0 = 1
            ! ix1 = nx
            do k=iz0,iz1
            do i=ix0,ix1
              wv(i,ny,k,ie) = 0.
            enddo
            enddo
          endif
        endif
      enddo
      call copy(w, wv, n)
      call adf_dssum(w) ! summed up

      do i=1,nx1*ny1*nz1*nelt
        if(w(i,1,1,1).lt.1e-7) then  ! one elem, right=outflow(t field)
          write(6,*) 'Error in rst mask',i,w(i,1,1,1),', set to 1.'
          w (i,1,1,1) = 1.
          wv(i,1,1,1) = 1.
        endif
        w(i,1,1,1) = 1./w(i,1,1,1)
      enddo

      call col2(wv,w,n) ! zero remains zero, otherwize 1/multiplic
      call outpost(vx,vy,vz,pr,wv,'   ')
c     call dssum(wv,lx1,ly1,lz1)
c     call outpost(vx,vy,vz,pr,wv,'   ')
c     call exitt

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_mask(wt,nx,ny,nz,l,w)
      include 'SIZE'
      include 'INPUT'
      integer nx,ny,nz,l
      real w(nx,ny,nz,nelt)
      real wt(nx,nz,2,ldim,nelt)

      integer ie
      integer lbr,rbr,lbs,rbs,lbt,rbt,two
c     init everything to 1

      n = nx*ny*nz*nelt
      call rone(w,n)

c     set dirichlet nodes to zero
      ierr = 0
      two  = 2
      do ie=1,nelt
         call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
         if (ierr.ne.0) then
            ierr = -1
            call adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,ie,two,ierr)
         endif

         if(lbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(1,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbr.eq.1) then
            do k=1,nz
            do j=1,ny
               w(nx,j,k,ie)=0.0
            enddo
            enddo
         endif
         if(lbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,1,k,ie)=0.0
            enddo
            enddo
         endif
         if(rbs.eq.1) then
            do k=1,nz
            do i=1,nx
               w(i,ny,k,ie)=0.0
            enddo
            enddo
         endif
         if(if3d) then
            if(lbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,1,ie)=0.0
               enddo
               enddo
            endif
            if(rbt.eq.1) then
               do j=1,ny
               do i=1,nx
                  w(i,j,nz,ie)=0.0
               enddo
               enddo
            endif
         endif
      enddo
c     do direct stiffness multiply

c     call hsmg_dsprod(w,l)
      call dsop(w,'mul',lx1,ly1,lz1) ! ! will work?

c     store weight
      if (.not. if3d) then
         do ie=1,nelt
            do j=1,ny
               wt(j,1,1,1,ie)=w(1,j,1,ie)
               wt(j,1,2,1,ie)=w(nx,j,1,ie)
            enddo
            do i=1,nx
               wt(i,1,1,2,ie)=w(i,1,1,ie)
               wt(i,1,2,2,ie)=w(i,ny,1,ie)
            enddo
         enddo
      else
         do ie=1,nelt
            do k=1,nz
            do j=1,ny
               wt(j,k,1,1,ie)=w(1,j,k,ie)
               wt(j,k,2,1,ie)=w(nx,j,k,ie)
            enddo
            enddo
            do k=1,nz
            do i=1,nx
               wt(i,k,1,2,ie)=w(i,1,k,ie)
               wt(i,k,2,2,ie)=w(i,ny,k,ie)
            enddo
            enddo
            do k=1,nz
            do j=1,ny
               wt(j,k,1,3,ie)=w(i,j,1,ie)
               wt(j,k,2,3,ie)=w(i,j,nz,ie)
            enddo
            enddo
         enddo
      endif

      ierrmx = iglmax(ierr,1)
      if (ierrmx.gt.0) then
         if ((ierr.gt.0).and.(nio.eq.0)) write(6,*) nid,ierr,' BC FAIL'
         call exitti('B INVALID BC FOUND in genfast$',ierrmx)
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_schwarz_wt(ifsqrt)
      include 'SIZE'
      include 'INPUT'
      include 'HSMGL'

      integer l,i,nl,nlz
      logical ifsqrt

      common /adfscw/ oswt, as_rstr_wt, as_mask, ras_mask
      real            oswt      (lx1,2*ldim,2,lelt)
     $              , as_rstr_wt(lx1,lz1,2*ldim,lelt)
     $              , as_mask   (lx1,lz1,2*ldim,lelt)
     $              , ras_mask  (lx1,ly1,lz1,lelt)

      call adf_setup_schwarz_wt_1(oswt,ifsqrt)

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_schwarz_wt_1(wt,ifsqrt)
      include 'SIZE'
      include 'INPUT'  ! if3d
      include 'TSTEP'  ! ifield
      include 'HSMGL'

      parameter(ls=lx1+2)
      real    wt(1)
      logical ifsqrt
      ! replace mg_work by tmp1, mg_work(i) by tmp2
      real tmp1(ls*ls*ls*lelt) ! not always on S grid
     $   , tmp2(ls*ls*ls*lelt) ! always on S grid

      integer enx,eny,enz !,pm

      zero =  0
      one  =  1
      onem = -1

      enx=lx1+2
      eny=ly1+2
      enz=lz1+2
      if(.not.if3d) enz=1
      ns = enx*eny*enz*nelfld(ifield) ! oversized
      i  = ns+1

c     call rone(mg_work(i),ns)
      call rone(tmp2,ns)

c     Sum overlap region (border excluded)
      call adf_extrude(tmp1,0,zero,tmp2,0,one ,enx,eny,enz)
      call adf_schwarz_dssum(tmp2)
      call adf_extrude(tmp2,0,one ,tmp1,0,onem,enx,eny,enz)
      call adf_extrude(tmp2,2,one,tmp2,0,one,enx,eny,enz)

      if(.not.if3d) then ! Go back to regular size array
         call adf_schwarz_toreg2d(tmp1,tmp2,lx1)
      else
         call adf_schwarz_toreg3d(tmp1,tmp2,lx1)
      endif
      call adf_dssum(tmp1)
      nx = lx1
      ny = ly1
      nz = lz1
      if (.not.if3d) nz=1
      nxyz = nx*ny*nz
      k    = 1
      do ie=1,nelfld(ifield)
c        call outmat(mg_work(k),nx,ny,'NEW WT',ie)
         call adf_setup_schwarz_wt_2(wt,ie,nx,tmp1(k),ifsqrt)
         k = k+nxyz
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_setup_schwarz_wt_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      real wt(1),work(1)
      logical ifsqrt

      if (ldim.eq.2) call adf_setup_schwarz_wt2d_2(wt,ie,n,work,ifsqrt)
      if (ldim.eq.3) call adf_setup_schwarz_wt3d_2(wt,ie,n,work,ifsqrt)

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_schwarz_wt2d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,4,2,nelt)
      real work(n,n)
      
      integer ie,i,j
      do j=1,n
         wt(j,1,1,ie)=1.0/work(1,j)
         wt(j,2,1,ie)=1.0/work(2,j)
         wt(j,3,1,ie)=1.0/work(n-1,j)
         wt(j,4,1,ie)=1.0/work(n,j)
      enddo
      do i=1,n
         wt(i,1,2,ie)=1.0/work(i,1)
         wt(i,2,2,ie)=1.0/work(i,2)
         wt(i,3,2,ie)=1.0/work(i,n-1)
         wt(i,4,2,ie)=1.0/work(i,n)
      enddo
      if(ifsqrt) then
         do ii=1,2
         do j=1,4
         do i=1,n
            wt(i,j,ii,ie)=sqrt(wt(i,j,ii,ie))
         enddo
         enddo
         enddo
      endif

      return
      end
c----------------------------------------------------------------------
      subroutine adf_setup_schwarz_wt3d_2(wt,ie,n,work,ifsqrt)
      include 'SIZE'
      logical ifsqrt
      integer n
      real wt(n,n,4,3,nelt) ! 4x3 is the same as 6x2
      real work(n,n,n)
      
      integer ie,i,j,k
      integer lbr,rbr,lbs,rbs,lbt,rbt

      ierr = 0
      do k=1,n
      do j=1,n
         wt(j,k,1,1,ie)=1.0/work(1,j,k)
         wt(j,k,2,1,ie)=1.0/work(2,j,k)
         wt(j,k,3,1,ie)=1.0/work(n-1,j,k)
         wt(j,k,4,1,ie)=1.0/work(n,j,k)
      enddo
      enddo
      do k=1,n
      do i=1,n
         wt(i,k,1,2,ie)=1.0/work(i,1,k)
         wt(i,k,2,2,ie)=1.0/work(i,2,k)
         wt(i,k,3,2,ie)=1.0/work(i,n-1,k)
         wt(i,k,4,2,ie)=1.0/work(i,n,k)
      enddo
      enddo
      do j=1,n
      do i=1,n
         wt(i,j,1,3,ie)=1.0/work(i,j,1)
         wt(i,j,2,3,ie)=1.0/work(i,j,2)
         wt(i,j,3,3,ie)=1.0/work(i,j,n-1)
         wt(i,j,4,3,ie)=1.0/work(i,j,n)
      enddo
      enddo
      if(ifsqrt) then
         do ii=1,3
         do k=1,4
         do j=1,4
         do i=1,n
            wt(i,j,k,ii,ie)=sqrt(wt(i,j,k,ii,ie))
         enddo
         enddo
         enddo
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_get_fast_bc(lbr,rbr,lbs,rbs,lbt,rbt,e,bsym,ier)
      integer                    lbr,rbr,lbs,rbs,lbt,rbt,e,bsym,ier
c
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'TOPOL'
      include 'TSTEP'
      include 'SOLN' ! vx, vy
c
      integer fbc(6)
      logical ifr

      real    w(lx1,ly1,lz1)
      common /scradf/ w

      common /logmn/ ifrstr
      logical        ifrstr
c
c     ibc = 0  <==>  Dirichlet, with extension
c     ibc = 1  <==>  Dirichlet, no extension, for boundaries
c     ibc = 2  <==>  Neumann,  domain boundary
c     ibc = 3  <==>  Neumann,  element boundary

      ! make them all Dirichlet as a start?

      do iface=1,2*ldim
         ied = eface(iface)
         ibc = -1

         if (ifmhd) call mhd_bc_dn(ibc,iface,e) ! can be overwritten by 'mvn'

         if (cbc(ied,e,ifield).eq.'   ' .or.
     $       cbc(ied,e,ifield).eq.'E  ' .or.
     $       cbc(ied,e,ifield).eq.'P  ' .or.
     $       cbc(ied,e,ifield).eq.'p  ')then
             ibc = 0
             if(ifrstr) then ! ifr = .true. : turn on Neumann
             fl = 0.
             call surface_flux(fl,vx,vy,vz,e,ied,w) ! face # ied or iface?
               if(fl.gt. 1.e-7) then
c                write(6,*) e,ied,fl,iface,'outflow face'
                 ibc = 2 ! fake neumann
               endif
             endif
         endif

         if (cbc(ied,e,ifield).eq.'T  ') ibc = 1
         if (cbc(ied,e,ifield).eq.'t  ') ibc = 1
         if (cbc(ied,e,ifield).eq.'O  ') ibc = 2
         if (cbc(ied,e,ifield).eq.'o  ') ibc = 2

         if (cbc(ied,e,ifield).eq.'f  ') ibc = 2
         if (cbc(ied,e,ifield).eq.'I  ') ibc = 2

         fbc(iface) = ibc

         if (ier.eq.-1) write(6,1) ibc,ied,e,ifield,cbc(ied,e,ifield)
  1      format(2i3,i8,i3,2x,a3,'  adf_get_fast_bc_error')

      enddo

      if (ier.eq.-1) call exitti('Error A adf_get_fast_bc$',e)

      lbr = fbc(1)
      rbr = fbc(2)
      lbs = fbc(3)
      rbs = fbc(4)
      lbt = fbc(5)
      rbt = fbc(6)

      ier = 0 
      if (ibc.lt.0) ier = lglel(e)

c     write(6,6) e,lbr,rbr,lbs,rbs,(cbc(k,e,ifield),k=1,4)
c   6 format(i5,2x,4i3,3x,4(1x,a3),'  adf_get_fast_bc')

      return
      end
c----------------------------------------------------------------------
c     gen_fast_spacing, from fast3d.f, for pressure grid
c-----------------------------------------------------------------------
      subroutine adf_swap_lengths

      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'WZ'
      common /swaplengths/ l(lx1,ly1,lz1,lelv)
      common /adflf/  lr(2*lx1+4),ls(2*lx1+4),lt(2*lx1+4)
     $              , llr(lelt),lls(lelt),llt(lelt)
     $              , lmr(lelt),lms(lelt),lmt(lelt)
     $              , lrr(lelt),lrs(lelt),lrt(lelt)
      real lr ,ls ,lt
      real llr,lls,llt
      real lmr,lms,lmt
      real lrr,lrs,lrt

      real l,l2d
      integer e

      n2 = lx1-1
      nz0 = 1
      nzn = 1
      nx  = lx1-2
      if (if3d) then
         nz0 = 0
         nzn = n2
      endif
      call plane_space(lmr,lms,lmt,0,n2,wxm1,xm1,ym1,zm1,nx,n2,nz0,nzn)

      n=n2+1
      if (if3d) then
         do e=1,nelt ! really should be nelt here !!
         do j=2,n2
         do k=2,n2
            l(1,k,j,e) = lmr(e)
            l(n,k,j,e) = lmr(e)
            l(k,1,j,e) = lms(e)
            l(k,n,j,e) = lms(e)
            l(k,j,1,e) = lmt(e)
            l(k,j,n,e) = lmt(e)
         enddo
         enddo
         enddo
         call adf_dssum(l)
         do e=1,nelt
            llr(e) = l(1,2,2,e)-lmr(e)
            lrr(e) = l(n,2,2,e)-lmr(e)
            lls(e) = l(2,1,2,e)-lms(e)
            lrs(e) = l(2,n,2,e)-lms(e)
            llt(e) = l(2,2,1,e)-lmt(e)
            lrt(e) = l(2,2,n,e)-lmt(e)
         enddo
      else
         do e=1,nelt
         do j=2,n2
            l(1,j,1,e) = lmr(e)
            l(n,j,1,e) = lmr(e)
            l(j,1,1,e) = lms(e)
            l(j,n,1,e) = lms(e)
c           call outmat(l(1,1,1,e),n,n,' L    ',e)
         enddo
         enddo
c        call outmat(l(1,1,1,25),n,n,' L    ',25)
         call adf_dssum(l)
c        call outmat(l(1,1,1,25),n,n,' L    ',25)
         do e=1,nelt
c           call outmat(l(1,1,1,e),n,n,' L    ',e)
            llr(e) = l(1,2,1,e)-lmr(e)
            lrr(e) = l(n,2,1,e)-lmr(e)
            lls(e) = l(2,1,1,e)-lms(e)
            lrs(e) = l(2,n,1,e)-lms(e)
         enddo
      endif

c     do ie=1,nelt
c     write(6,*) llr(ie),lmr(ie),lrr(ie),lls(ie),lms(ie),lrs(ie),ie
c    $  ,nelv,nelt, 'inside'
c     enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_swap_lengths_fix

      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'WZ'
      common /swaplengths/ l(lx1,ly1,lz1,lelv)
      common /adflf/  lr(2*lx1+4),ls(2*lx1+4),lt(2*lx1+4)
     $              , llr(lelt),lls(lelt),llt(lelt)
     $              , lmr(lelt),lms(lelt),lmt(lelt)
     $              , lrr(lelt),lrs(lelt),lrt(lelt)
      real lr ,ls ,lt
      real llr,lls,llt
      real lmr,lms,lmt
      real lrr,lrs,lrt

      real l,l2d
      integer e

      !  hack so that none of the lengths is 0
      do ie=1,nelt
        if(llr(ie).le.1.e-7) then
          llr(ie) = lmr(ie)
        endif
        if(lrr(ie).le.1.e-7) then
          lrr(ie) = lmr(ie)
        endif
        if(lls(ie).le.1.e-7) then
          lls(ie) = lms(ie)
        endif
        if(lrs(ie).le.1.e-7) then
          lrs(ie) = lms(ie)
        endif
        if(lmr(ie).le.1.e-7) then
          write(6,*) 'wrong lmr value',ie,lmr(ie)
          call exitt
        endif
        if(lms(ie).le.1.e-7) then
          write(6,*) 'wrong lms value',ie,lms(ie)
          call exitt
        endif
        if(ldim.eq.3) then
          if(llt(ie).le.1.e-7) then
            llt(ie) = lmt(ie)
          endif
          if(lrt(ie).le.1.e-7) then
            lrt(ie) = lmt(ie)
          endif
          if(lmt(ie).le.1.e-7) then
            write(6,*) 'wrong lmt value',ie,lmt(ie)
            call exitt
          endif
        endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_gen_fast_spacing(x,y,z)
c
c     Generate fast diagonalization matrices for each element
c
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'SOLN'
      include 'WZ'
c
      parameter(lxx=lx1*lx1)
c
      common /adflf/  lr(2*lx1+4),ls(2*lx1+4),lt(2*lx1+4)
     $              , llr(lelt),lls(lelt),llt(lelt)
     $              , lmr(lelt),lms(lelt),lmt(lelt)
     $              , lrr(lelt),lrs(lelt),lrt(lelt)
      real lr ,ls ,lt
      real llr,lls,llt
      real lmr,lms,lmt
      real lrr,lrs,lrt
      integer lbr,rbr,lbs,rbs,lbt,rbt,e
      real x(lx1,ly1,lz1,nelt)
      real y(lx1,ly1,lz1,nelt)
      real z(lx1,ly1,lz1,nelt)
      real axwt(lx2)

      ierr = 0

c     if (param(44).eq.1) then ! for FEM?
c                                       __ __ __
c        Now, for each element, compute lr,ls,lt between specified planes
c
         n1 = lx2
         n2 = lx2+1

         nz0 = 1
         nzn = 1
         if (if3d) then
            nz0= 0
            nzn=n2
         endif
         eps = 1.e-7
         if (wdsize.eq.8)  eps = 1.e-14

         ! why passing in xm1, ym1, zm1, but use wxm2?
c
c        Find mean spacing between "left-most" planes
         call adf_plane_space2(llr,lls,llt, 0,wxm2,x,y,z,n1,n2,nz0,nzn)
c
c        Find mean spacing between "middle" planes
         call adf_plane_space (lmr,lms,lmt, 1,n1,wxm2,x,y,z
     $                        ,n1,n2,nz0,nzn)
c
c        Find mean spacing between "right-most" planes
         call adf_plane_space2(lrr,lrs,lrt,n2,wxm2,x,y,z,n1,n2,nz0,nzn)
c
c     else
c        call load_semhat_weighted    !   Fills the SEMHAT arrays
c     endif

      return
      end
c-----------------------------------------------------------------------
      subroutine adf_plane_space(lr,ls,lt,i1,i2,w,x,y,z,nx,nxn,nz0,nzn)
c
c     Here, spacing is based on harmonic mean.  pff 2/10/07
c
c
      include 'SIZE'
      include 'INPUT'
c
      real w(1),lr(1),ls(1),lt(1)
      real x(0:nxn,0:nxn,nz0:nzn,1)
      real y(0:nxn,0:nxn,nz0:nzn,1)
      real z(0:nxn,0:nxn,nz0:nzn,1)
      real lr2,ls2,lt2
c                                    __ __ __
c     Now, for each element, compute lr,ls,lt between specified planes
c
      ny = nx
      nz = nx
      j1 = i1
      k1 = i1
      j2 = i2
      k2 = i2
c
      do ie=1,nelt
c
         if (if3d) then
            lr2  = 0.
            wsum = 0.
            do k=1,nz
            do j=1,ny
               weight = w(j)*w(k)
c              lr2  = lr2  + ( (x(i2,j,k,ie)-x(i1,j,k,ie))**2
c    $                     +   (y(i2,j,k,ie)-y(i1,j,k,ie))**2
c    $                     +   (z(i2,j,k,ie)-z(i1,j,k,ie))**2 )
c    $                     *   weight
               lr2  = lr2  +   weight /
     $                       ( (x(i2,j,k,ie)-x(i1,j,k,ie))**2
     $                     +   (y(i2,j,k,ie)-y(i1,j,k,ie))**2
     $                     +   (z(i2,j,k,ie)-z(i1,j,k,ie))**2 )
               wsum = wsum + weight
            enddo
            enddo
            lr2     = lr2/wsum
            lr(ie)  = 1./sqrt(lr2)
c
            ls2 = 0.
            wsum = 0.
            do k=1,nz
            do i=1,nx
               weight = w(i)*w(k)
c              ls2  = ls2  + ( (x(i,j2,k,ie)-x(i,j1,k,ie))**2
c    $                     +   (y(i,j2,k,ie)-y(i,j1,k,ie))**2
c    $                     +   (z(i,j2,k,ie)-z(i,j1,k,ie))**2 )
c    $                     *   weight
               ls2  = ls2  +   weight /
     $                       ( (x(i,j2,k,ie)-x(i,j1,k,ie))**2
     $                     +   (y(i,j2,k,ie)-y(i,j1,k,ie))**2
     $                     +   (z(i,j2,k,ie)-z(i,j1,k,ie))**2 )
               wsum = wsum + weight
            enddo
            enddo
            ls2     = ls2/wsum
            ls(ie)  = 1./sqrt(ls2)
c
            lt2 = 0.
            wsum = 0.
            do j=1,ny
            do i=1,nx
               weight = w(i)*w(j)
c              lt2  = lt2  + ( (x(i,j,k2,ie)-x(i,j,k1,ie))**2
c    $                     +   (y(i,j,k2,ie)-y(i,j,k1,ie))**2
c    $                     +   (z(i,j,k2,ie)-z(i,j,k1,ie))**2 )
c    $                     *   weight
               lt2  = lt2  +   weight /
     $                       ( (x(i,j,k2,ie)-x(i,j,k1,ie))**2
     $                     +   (y(i,j,k2,ie)-y(i,j,k1,ie))**2
     $                     +   (z(i,j,k2,ie)-z(i,j,k1,ie))**2 )
               wsum = wsum + weight
            enddo
            enddo
            lt2     = lt2/wsum
            lt(ie)  = 1./sqrt(lt2)
c
         else              ! 2D
            lr2 = 0.
            wsum = 0.
            do j=1,ny
               weight = w(j)
c              lr2  = lr2  + ( (x(i2,j,1,ie)-x(i1,j,1,ie))**2
c    $                     +   (y(i2,j,1,ie)-y(i1,j,1,ie))**2 )
c    $                     *   weight
               lr2  = lr2  + weight /
     $                       ( (x(i2,j,1,ie)-x(i1,j,1,ie))**2
     $                       + (y(i2,j,1,ie)-y(i1,j,1,ie))**2 )
               wsum = wsum + weight
            enddo
            lr2     = lr2/wsum
            lr(ie)  = 1./sqrt(lr2)
c
            ls2 = 0.
            wsum = 0.
            do i=1,nx
               weight = w(i)
c              ls2  = ls2  + ( (x(i,j2,1,ie)-x(i,j1,1,ie))**2
c    $                     +   (y(i,j2,1,ie)-y(i,j1,1,ie))**2 )
c    $                     *   weight
               ls2  = ls2  + weight /
     $                       ( (x(i,j2,1,ie)-x(i,j1,1,ie))**2
     $                     +   (y(i,j2,1,ie)-y(i,j1,1,ie))**2 )
               wsum = wsum + weight
            enddo
            ls2     = ls2/wsum
            ls(ie)  = 1./sqrt(ls2)
c           write(6,*) 'lrls',ie,lr(ie),ls(ie)
         endif
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine adf_plane_space2(lr,ls,lt,i1,w,x,y,z,nx,nxn,nz0,nzn)
c
c     Here, the local spacing is already given in the surface term.
c     This addition made to simplify the periodic bdry treatment.
c
c
      include 'SIZE'
      include 'INPUT'
c
      real w(1),lr(1),ls(1),lt(1)
      real x(0:nxn,0:nxn,nz0:nzn,1)
      real y(0:nxn,0:nxn,nz0:nzn,1)
      real z(0:nxn,0:nxn,nz0:nzn,1)
      real lr2,ls2,lt2
c                                    __ __ __
c     Now, for each element, compute lr,ls,lt between specified planes
c
      ny = nx
      nz = nx
      j1 = i1
      k1 = i1
c
      do ie=1,nelt
c
         if (if3d) then
            lr2  = 0.
            wsum = 0.
            do k=1,nz
            do j=1,ny
               weight = w(j)*w(k)
               lr2  = lr2  + ( (x(i1,j,k,ie))**2
     $                     +   (y(i1,j,k,ie))**2
     $                     +   (z(i1,j,k,ie))**2 )
     $                     *   weight
               wsum = wsum + weight
            enddo
            enddo
            lr2     = lr2/wsum
            lr(ie)  = sqrt(lr2)
c
            ls2 = 0.
            wsum = 0.
            do k=1,nz
            do i=1,nx
               weight = w(i)*w(k)
               ls2  = ls2  + ( (x(i,j1,k,ie))**2
     $                     +   (y(i,j1,k,ie))**2
     $                     +   (z(i,j1,k,ie))**2 )
     $                     *   weight
               wsum = wsum + weight
            enddo
            enddo
            ls2     = ls2/wsum
            ls(ie)  = sqrt(ls2)
c
            lt2 = 0.
            wsum = 0.
            do j=1,ny
            do i=1,nx
               weight = w(i)*w(j)
               lt2  = lt2  + ( (x(i,j,k1,ie))**2
     $                     +   (y(i,j,k1,ie))**2
     $                     +   (z(i,j,k1,ie))**2 )
     $                     *   weight
               wsum = wsum + weight
            enddo
            enddo
            lt2     = lt2/wsum
            lt(ie)  = sqrt(lt2)
c           write(6,1) 'lrlslt',ie,lr(ie),ls(ie),lt(ie)
    1       format(a6,i5,1p3e12.4)
c
         else
            lr2 = 0.
            wsum = 0.
            do j=1,ny
               weight = w(j)
               lr2  = lr2  + ( (x(i1,j,1,ie))**2
     $                     +   (y(i1,j,1,ie))**2 )
     $                     *   weight
               wsum = wsum + weight
            enddo
            lr2     = lr2/wsum
            lr(ie)  = sqrt(lr2)
c
            ls2 = 0.
            wsum = 0.
            do i=1,nx
               weight = w(i)
               ls2  = ls2  + ( (x(i,j1,1,ie))**2
     $                     +   (y(i,j1,1,ie))**2 )
     $                     *   weight
               wsum = wsum + weight
            enddo
            ls2     = ls2/wsum
            ls(ie)  = sqrt(ls2)
            write(6,*) 'lrls',ie,lr(ie),ls(ie),lt(ie)
         endif
      enddo
      return
      end
c----------------------------------------------------------------------
